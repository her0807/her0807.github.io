{"componentChunkName":"component---src-templates-blog-template-js","path":"/os/process_vs_thread/","result":{"data":{"cur":{"id":"02717f2c-6cb8-5008-9579-e940b18a5920","html":"<p>프로세스와 스레드를 학습하기에 앞서, 이해하고 있으면 좋은 개념인 CPU 와 RAM 에 대해서 간단히 알아보아요! ☺️</p>\n<h3 id=\"cpu란-core-processing-unit\" style=\"position:relative;\"><a href=\"#cpu%EB%9E%80-core-processing-unit\" aria-label=\"cpu란 core processing unit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU란? (core processing unit)</h3>\n<p>중앙 처리 장치로 컴퓨터를 통한 연산과 수행, 프로그램 실행을 담당하고 있어요\nCPU 는 출력을 전달하기 전에 RAM 에서 입력을 가져와 명령문을 이해하고 처리합니다.</p>\n<h3 id=\"ram란random-access-memory\" style=\"position:relative;\"><a href=\"#ram%EB%9E%80random-access-memory\" aria-label=\"ram란random access memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RAM란?(Random access memory)</h3>\n<p>프로그램이 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리 RAM 이란 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스할 수 있는 데이터 저장소입니다.</p>\n<ul>\n<li>데이터를 가져오기, 디코딩, 실행이 세가지가 cpu 의 핵심이자 전부에요!</li>\n</ul>\n<blockquote>\n<h2 id=\"프로세스process\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process\" aria-label=\"프로세스process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스(Process)</h2>\n</blockquote>\n<p>프로세스란 실행중인 프로그램을 뜻합니다. 즉, 파일 형태로 존재하던 프로그램이 메모리에 적재되어 CPU 에 의해 실행되는 것을 Process 라고 합니다.</p>\n<h3 id=\"메모리에-적재\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%81%EC%9E%AC\" aria-label=\"메모리에 적재 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리에 적재</h3>\n<p>메모리는 CPU가 직접 접근 할 수 있는 컴퓨터 내부의 기억 장치 입니다. Program이 CPU에서 실행되려면 해당 내용이 memory에 적재된 상태여야만 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACcklEQVQoz22SbU/aUBiGO7e5gEyNgEgLpS0tLRQKbXmzivg2dVl0L8IWjdmHKUyj/oFt3/bDr6XHaTTbhzvPyX1yrtzP8xzp8vKSbxfnnJ9fcHExYTr9zmQyFYrP02nsTYUmkwk3N7f8+PmLy6srRqMR4/FY1JOTE66vr5FktYxttTGsBqppk1cs5KKNojqsyBqZTJpMNksmkxHKZrPkZZlEIoEkSU+0vLyM5LgBnfYe7e4W7Z13+NvvqTUjat4atuNhaCUMXadcLj/INE0KRZlEcharUmZ+MUU2t4RlWUiVapNGa4OwvUOwfkDn7Rfc1kBAq0GE6daxGk10XUfTNCHDMJALK7yYnaHiWKTmkyxlF4Uv2TUf11uj1dzAC4cEnV381gZ+e5tGfwvLa2H74T/AvLLCy1fPBXjudYKlzCNgzVun09sjCAbU6l0qbgfH7WGaNUpFhZJaFKB7aPwwnU4/md/c3JwYhwDWWwM8f4DbXMWp9+7UWMVyvL8gQ8D+B3w2MyNqKpW6A8ZLqfubhNEO1dYqTiPCDYf4b46xG200VX0C03RdLCXe+OOEyWTyrmXDtNAUA/96QO/jBqvtNapuHU0voxtlSqXSE1mVCv0oEnV+YQGl2SeTV8iv5DDihKqqEgYBJ+enjE8/E/oBplnGMHSh+CtUq1UcxxEtxSlEYk3DbXgMb3+zczRiuL5GpWIjxZd7+/scf/jE6HhEt9cT88nlcqJapkm32yUMQ+HFnzf28/k8u7u7fD074+jwENu2KRQKSK7r0u/36fX7DDeHdDodZFmmWCyKGqe6ByqKIh7FftxZFEUcHBywtb390Mkfk9lnQ2C9l+sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1.png\"\n        title=\"1.png\"\n        src=\"/static/12774ef549f4c080492277c15148348f/37523/1.png\"\n        srcset=\"/static/12774ef549f4c080492277c15148348f/e9ff0/1.png 180w,\n/static/12774ef549f4c080492277c15148348f/f21e7/1.png 360w,\n/static/12774ef549f4c080492277c15148348f/37523/1.png 720w,\n/static/12774ef549f4c080492277c15148348f/f6f78/1.png 932w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스에 할당되는  공간은 code, data, stack, heap 4개 의 영역으로 이루어져 있으며, 각 Process 마다 독립적으로 할당 받습니다.</p>\n<table>\n<thead>\n<tr>\n<th>code 영역</th>\n<th>실행한 프로그램의 코드가 저장됨</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data 영역</td>\n<td>전역 변수와 static 변수가 저장</td>\n</tr>\n<tr>\n<td>heap 영역</td>\n<td>프로그래머가 직접 할당, 해제 하는 공간</td>\n</tr>\n<tr>\n<td>stack 영역</td>\n<td>함수 호출시 생성되는 지역변수와 매개변수가 저장</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cpu의-연산과-pc-regisgter\" style=\"position:relative;\"><a href=\"#cpu%EC%9D%98-%EC%97%B0%EC%82%B0%EA%B3%BC-pc-regisgter\" aria-label=\"cpu의 연산과 pc regisgter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU의 연산과 PC regisgter</h2>\n<p>프로그램 코드를 토대로 CPU가 실제로 연산을 해야만 프로그램이 실행된다고 볼 수 있어요. 어떤 코드를 읽어야하는 것을 정하는 것은 CPU 내부에 있는 PC(program counter) register 에 저장되어 있습니다.  여기에는 다음에 실행될 코드의 주소값이 저장되어 있는데요.  즉 메모리에 code 영역의 명령중 다음번 연산에서 읽어야할 명령어의 주소값을 PC register가 순차적으로 가리키게 되고, 해당 명령어를 읽어와서 CPU 가 연산을 시작하면 프로세스가 되는 것 입니다!</p>\n<h2 id=\"멀티-프로세스-vs-멀티-스레드\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"멀티 프로세스 vs 멀티 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 vs 멀티 스레드</h2>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 말합니다. 동시에라는 말은 동시성과 병렬성 두가지를 의미합니다.</p>\n<p><code class=\"language-text\">동시성</code>은 CPU core 가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게되는 <code class=\"language-text\">시분할 시스템</code>으로 실행되는 것<code class=\"language-text\">병렬성</code>은 CPU core 가 여러개일 떄 <code class=\"language-text\">각각의 core 가 각각의 Process</code>를 연산함으로써 Process가 동시에 실행되는 것입니다.\n동시성은 실제로는 하나의 작업만 이뤄지는데 동시에 처리되는 것 같이 보이는 것을 의미하고, 병렬성은 실제로 여러 코어가 여러 작업을 실행하고 있는 것을 의미합니다.</p>\n<h3 id=\"멀티-프로세스\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"멀티 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스</h3>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 말합니다 이 때 <code class=\"language-text\">프로세스들은 CPU 와 메모리를 공유</code>하게 됩니다.\n메모리의 경우에는 여러 프로세스들이 각자의 메모리 영역을 차지하여 동시에 적재됩니다. 반면 하나의 CPU 는 매순간 하나의 프로세스만 연산할 수 있습니다. 하지만 CPU의 처리 속도가 워낙 빨라서 수ms 이내의 짧은 시간동안 여러 프로세스들이 CPU에서 번갈아가며 실행되기 때문에 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것 처럼 보입니다.</p>\n<p>이처럼 CPU의 작업 시간을 여러 프로세스들이 조금씩 나누어 쓰는 시스템을 <code class=\"language-text\">시분할 시스템</code>이라고 부릅니다.</p>\n<h3 id=\"메모리-관리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\" aria-label=\"메모리 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리</h3>\n<p>여러 프로세스가 동시에 메모리에 적재된 경우, 서로 다른 프로세스의 영역을 침범하지 않도록 각 Process가 자신의 메모리 영역에만 접근하도로 운영체제가 관리해줍니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACX0lEQVQoz12SWW/TQBSFncWJs3i3s9R24rGdTUUkrQAJ8TNIn+Gl6l4JKh4gSEHqpkr9B33pP/3QjEgXHo7OHc/1ucsc7eHhgdvbW+7u7ri6uuL6+lrx5eWlws3NjcLmu4z/rNdcfP/G6tdPflxc8Hu1Yr1e8/j4iBaGIY7rYlsmPZGTfvjE8N1HBov3BJ0uruvieR5BENDpdOj2+3iWiaZp+Lal2KiU8X2f8XiMlmUZs9mM+WJBVhTEyYAoSRhkOXlRMJlMmE6nikejEUUxQiQxrZrOm+kUp92iH/iMioLFzg5amqaMJxPezue4lomh6zimiV4uMRwkFKMRMmcD2UDU71Mvlwg9F6NaIXAdhBDM53M0GQyHQ0SaYrdbNBsGrm1Tq1ZIoi2VKIU2LAW7vS5aSVPjStiOre6U4KZynuc4joVR1zHbTYx6lTiOlMD/glHcp1orkxcZRqOO57/oMBXPgrZr02y38cOAWsMgTmIykb0aWYiMeLCF0aySFSkt0yDsei8FxT/BAst1abZb+IFPrdEgSgYIkb7eoZAdRuiGzlYSYbQM/NB/vcPNKG3Lpt5oYjkuFb1OMhyql5V3T3lC0I8TKnWDfDyh3mrhBOGzoBxV/iStYVnW06JLJY04jpVdXlpnPB4xEDmG5VBMZ5iuTyeKlRt2d3fRPNclimNm29vYtk2lUkHXdaq6rs7SsNLYkoMwpNfrYdqOKiqnUcWrOp7vq3fQVqsVBwcHHB0dcXp6yvn5OWdnZ4rl+eTkROH4+FjlyHh/f5+9vT2WyyXL5We+fvnC4eEh9/f3/AWrH2FEMhKjXAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2.png\"\n        title=\"2.png\"\n        src=\"/static/a553ff759ab4df92069dcdd96e974235/37523/2.png\"\n        srcset=\"/static/a553ff759ab4df92069dcdd96e974235/e9ff0/2.png 180w,\n/static/a553ff759ab4df92069dcdd96e974235/f21e7/2.png 360w,\n/static/a553ff759ab4df92069dcdd96e974235/37523/2.png 720w,\n/static/a553ff759ab4df92069dcdd96e974235/ecf19/2.png 948w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"cpu의-연산과-pc-레지스터\" style=\"position:relative;\"><a href=\"#cpu%EC%9D%98-%EC%97%B0%EC%82%B0%EA%B3%BC-pc-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0\" aria-label=\"cpu의 연산과 pc 레지스터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU의 연산과 PC 레지스터</h3>\n<p>CPU는 PC register가 가리키고 있는 명령어를 읽어들여 연산을 진행합니다. pc register 에는 다음에 실행될 명령어의 주소값이 저장되어 있어요. 멀티 프로세스 시스템에서는 <code class=\"language-text\">프로세스1 이 실행</code>되고 있을 때는 <code class=\"language-text\">프로세스1의 code 영역을 pc register</code>가 가리키다가, <code class=\"language-text\">process2가 진행되면</code> <code class=\"language-text\">prcess2의 code 영역을 가리키게 된다.</code> CPU는 PC register가 가리키는 곳에 따라 process를 변경해 가면서 명령어를 읽어들이고 연산하게 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB8UlEQVQoz1WSS08TURiGhxigTSuUlnYunTm3mc4Uyx0RwkKCmggY48aNSSudNvwHEoMrV/ov/Bf+JjcujNvHnMOlsHhzvvNdnrzn4l1eXjKdTinLcqbxzTqZTFzNysbj8ZhyMsHOjIbDe30ejbi4uHAznu/7WAVB8ECzvf8oHxBGEVIImisrBL5PGAT3sa17aZpyJyEUu/u7XH+7ZrA+QCnl8kYpjNZouzeGzc0NZByjRYKySmJSozFpiqe1QiuN1prUSPprPd69fUWWpQ6YKE2Ur5FkBdnGFpsHR5wdH+N5HvVajaWlJeY8DxF30cbMgNIoPn2s8uG94Wd5zna/RywlxhhMXmCyHjrr0R+sc7j3nOV6nWZjmVajQeNpHZkkzpSnboH2SE++e5yMNH+uSl6sF0RCuryS0rm1qzWQ5zlJEru7lCJxsa0/BhqN92OOl0PNv6uSg4dAfXMldsg6zoucbjfCzRpNN45mQH3bnGpNayfg7GjA369jDgYzoH4A7GUZ+9tbtFabtDst2u0Wq+0mUskboJQSK/uCQSA43R7w+8uQ/bWcMBEuL2+PLISgKArevD5xj1KtVqnVai6+c+mFYYhVFIY0/Q6HheHX+JRnSrDa8V3+rsf+Vwvd3dthYWGeSmWRSqXCwuI8Hb/jev4DwWMovVZHzqEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3.png\"\n        title=\"3.png\"\n        src=\"/static/4d49e96aeb29e57d38e6263d49693ca2/37523/3.png\"\n        srcset=\"/static/4d49e96aeb29e57d38e6263d49693ca2/e9ff0/3.png 180w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/f21e7/3.png 360w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/37523/3.png 720w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/1b1d5/3.png 876w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"context\" style=\"position:relative;\"><a href=\"#context\" aria-label=\"context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context</h2>\n<p>시분할 시스템에서는 한 프로세스가 매우 짧은 시간동안 CPU 를 점유하여 일정 부분 명령을 수행하고, 다른 프로세스에게 넘기게 돼요. 그후 다시 차례가 되면 다시 CPU 를 점유하여 명령을 수행하죠 따라서 이전에 어디까지 명령을 수행했고, register에는 어떤 값이 저장되어 있었는지에 대한 정보가 필요하게 됩니다. process가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보가 바로 context 입니다!  context 정보들은 PCB(Process Control Block) 에 저장한답니다.</p>\n<h3 id=\"pcbprocess-control-block\" style=\"position:relative;\"><a href=\"#pcbprocess-control-block\" aria-label=\"pcbprocess control block permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB(Process Control Block)</h3>\n<p>PCB 운영체제가 프로세스를 표현한 자료구조입니다. 해당 공간에는 프로세스의 중요한 정보가 포함되어 있기 때문에 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 저장되어요. 일부 운영체제에서 PCB는 커널 스택에 위치합니다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABsElEQVQoz01SCXKEMAzj/y8sdApsgRxAIBCOsJc6Mt1tmfHYYEWWFZIj7tCqwrrM2LeAbQ1YV9YL4r4ixhVHPDPfj7jhOLYz/0bclzPHiCTuG+rqgskP8H5AmD1CmM6YPeZ5xDyN7x5x4+h+e156FEFh27Yhud1u6PsOdV0jyzK0rUXf97iUJbTWqKoKVfWNz88MeZ4jTT8kF0Uh+XIpMQwDns8n9n0/CbVWsNZiWRas6wqlGmRpijz/kgNNU0tNzDRNGMdRwnuqnOGce59NrtcriiIXFfSAH0MIAuZk1pzMdYilAOJIQHL2SUo8QxR2XQvnejnAYF1XlaxsrYE1RixpmgZlWYhqWkPlrMuiEPUkTu73u4CyLJVVScipVEeQ6/v3ewiz1Mtyqn4pm7wXxQxRaLQWlQTRXIKojt4opdB1Hdq2Rde2mCYvQ4bBwftRVBtjMDj3dynGaLlZevN4PGSyliGdDONfQDKSc0hrrQhgXzWNrE4OUUgSfiCAt83JXIuE9KeuTy+pRLyzp3daKfGWwT+AGLnl4zjEt/8PVXJ1Bj1+YVgz2H89xLwukyv/ALZMQwXhfUoiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4.png\"\n        title=\"4.png\"\n        src=\"/static/d00c1890f185efc4dcc33749f52e7c79/37523/4.png\"\n        srcset=\"/static/d00c1890f185efc4dcc33749f52e7c79/e9ff0/4.png 180w,\n/static/d00c1890f185efc4dcc33749f52e7c79/f21e7/4.png 360w,\n/static/d00c1890f185efc4dcc33749f52e7c79/37523/4.png 720w,\n/static/d00c1890f185efc4dcc33749f52e7c79/eb3fa/4.png 1026w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>PCB 에는 프로세스 상태와 PC(program counter(PC) 해당 process 가 다음에 실행할 명령어의 주소를 가리킵니다.</p>\n</blockquote>\n<h3 id=\"context-switch\" style=\"position:relative;\"><a href=\"#context-switch\" aria-label=\"context switch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context switch</h3>\n<p>한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말해요.\n이때 이전의 프로세스의 상태를 PCB에 저장하여 보관하고, 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구하는 작업이 이뤄져요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABtElEQVQ4y5WSW2/aQBCF/ZwKcbGxvb6tsb1QCCG4LU5UErWVEhKBFLUPyW/xDXit8qdPNStt6xLUNA9HZ23PfHt2vNput8N+vwf5drtFVVX4+fyM3X6LIi+Q5wXKskJd1fK7qqvr+reXZYk8z1EUBTRd16FkGAZ6vR6+3a4wywTSpcD8s8CHqyFC4ULvUc2fetXTlBbHMZqKogir9RpJEiMWkdR4OkScRBgMBjisP5RGRaQwDKUI+O7kBLbNEAQBHMeFZdrwPR/tdhumacoaqlW9Tb0A0rrb7cpGOkK/35fHtCwLrVZLOiVpQppw7fAlued5sokScs6lU6pECDDmwncDeG6AwOfgPPwrkHZsJ3IFU/J9H5vvD1jefMSn5RTZ9RnmizFOz0fHEzahlEYlU0Ba3202SLMzpBcTLAiYTTB8n7w+Qxq+bdsyleu6cBxHum4YMPsWAo+/fuRDIMFolowx2LYlnzudDkzLfPtPYcyBZTJ5XUiUioCUmtL+97Uh5wHHan2P+WKCyUxgmo4wngoMolDOsrnxP4FKBPzx9Ijs+hwXX2a4uk1x+XUGMYpfjOYY8BdXdHyGT1OLowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5.png\"\n        title=\"5.png\"\n        src=\"/static/45ccf41f18b7818e5dbb389642094cdd/37523/5.png\"\n        srcset=\"/static/45ccf41f18b7818e5dbb389642094cdd/e9ff0/5.png 180w,\n/static/45ccf41f18b7818e5dbb389642094cdd/f21e7/5.png 360w,\n/static/45ccf41f18b7818e5dbb389642094cdd/37523/5.png 720w,\n/static/45ccf41f18b7818e5dbb389642094cdd/d7542/5.png 810w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-스레드란\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%9E%80\" aria-label=\"멀티 스레드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 스레드란?</h2>\n<p>스레드는 <code class=\"language-text\">한 프로세스 내에서 실행되는 동작(기능)의 단위</code>입니다.\n각 쓰레드는 속해있는 프로세스의 스택 메모리를 제외한 나머지 영역을 공유할 수 있습니다.</p>\n<p><code class=\"language-text\">멀티 쓰레드란 하나의 프로세스가 동시에 여러개의 일을 수행할 수 있도록 해주는 것</code>이다. 즉 하나의 프로세스에서 여러 작업을 병렬로 처리하기 위해서 멀티 쓰레드를 사용합니다.</p>\n<p>쓰레드는 프로세스 내에서 독립적인 기능을 수행합니다. 즉, 독립적으로 함수를 호출함을 의미하고, 이를 위해 스택 메모리가 각자 필요합니다. 쓰레드가 무엇인지 이해하고, 멀티 프로세스와 어떤 점이 다른지를 생각해보면서 공부하면 좋을 듯 합니다.</p>\n<h3 id=\"stack-memory--pc-register\" style=\"position:relative;\"><a href=\"#stack-memory--pc-register\" aria-label=\"stack memory  pc register permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack memory &#x26; PC register</h3>\n<p>스레드가 함수를 호출하기 위해서는 인자 전달, return Address 저장, 함수 내 지역변수 저장 등을 위한 독립적인 stack memory 공간을 필요로 합니다. 결과적으로 스레드는 프로세스로부터 스택 메모리 영역은 독립적으로 할당받고, 나머지 영역은 공유하게 되어요</p>\n<p>또한 멀티 스레드에서는 각각 스레드마다 PC 레지스터를 가지고 있어야해요. 그 이유는 한 프로세스 내에서도 쓰레드끼리 context swich가 일어나게 되는데 PC 레지스터에 code address가 저장되어 있어야 이어서 실행을 할 수 있기 때문이에요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADRUlEQVQ4y4WUz29UVRTHJ9EYZWNIjBtjjMiOhUtj9B9wYaNhgwYK9UdAlAW2SVEqIlEgtcKiZKxTNEgCo4mBgaYgQqGdQmmTdlqmi47Tmc77/ea9aWcYp3ba+fUx99I3VCbam5z37nv33m8+59xzjq9UKrG4uMjS0hKFQoHFQoFMbolZNUvoSpjBkSiK9Re5/N+USiuI/SsrKywvL8u3910ul6nVavjEj/n5eWzbRtN01FSczrP3aGq9yc4jo2z/8g5Nbbc43x9FUxIYhkk8HicWi5FMJlFVlUQiIc+L4RMPx3Hkgm2nWchYHOmNsLV9iG2fh3nnYJg3W4c4E5pCVxMYpiXFZmZmSKVS6LouhYWgJBSPtSNtafzUF2Pn17fZ8+1dae8dG+H3OwkyjoXrZnBdVwqYpilhxDuXy1GpVB4Qinjk83nu5/M4ls7ZW0n29kboCE7z2bkoewLjDEQt1hsifFIwnU6jKAppx8W1DQLXk7T03OPgrzHagzM0+ye5MmHKQ5VqVbq21qrV6oM1Qdjoss6PfZM0f9PPxyeus/fEH3J+bTQh16vVWgOZp9EQQ7E5O+/wfqsf37Nbeeql7WzYvEPOTwb6Vimq/ylYj6EI8NzcHIqiks9leHdfN09s2sGLr+7jhVc+4cnNzXR+f1keKv+PoHBdEhaLRZnYxeIy2QWHXfv9+J7fxjMvf8TTWz7Et/EtjnZfXBWsrC9Yd7kGuazL2x904Xv8DXwbXuOx55rY9PqnBEO36249eikNgmvNtkwuXxtj94HTtOxuY2DghsexbtrUb/mhga6rTMUXGIhk6fRfoPeXMP13XcanFTRVwXFcmWKiSgzDkJUiElvQSUIvh7xhWxo/98VoPzXBIf8Ih3vGOHBqgvCEIZyiVC7LBH7UPKj6pchKuZ/HNDSGIyYXhiwOdQXpClwlNJxmfFqVa24mg6ZpsvYFmWdebOtpIzZYto2bNjl3Nc4XP0zR0T3IVz0jdPRMMhx5SCgARLmKllVeJfYqpqFSdHWO324k6Tofp6Wtl/1HQ3wXnOXm6Cy2qcvmIAiFWZbVSCiaq9c1RIANTeHSYIrjZ6Y4fSlO4OKfcj4WNalWRGP9d5P1zIvhPxwp+5mn/pwiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6.png\"\n        title=\"6.png\"\n        src=\"/static/12c28b038387e80d2030a27ab8967e6d/37523/6.png\"\n        srcset=\"/static/12c28b038387e80d2030a27ab8967e6d/e9ff0/6.png 180w,\n/static/12c28b038387e80d2030a27ab8967e6d/f21e7/6.png 360w,\n/static/12c28b038387e80d2030a27ab8967e6d/37523/6.png 720w,\n/static/12c28b038387e80d2030a27ab8967e6d/0a867/6.png 986w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-프로세스-vs-멀티-스레드-1\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-1\" aria-label=\"멀티 프로세스 vs 멀티 스레드 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 vs 멀티 스레드</h2>\n<ul>\n<li>멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 컨텍스트 스위칭이 빠르다.</li>\n<li>멀티 프로세스는 멀티 스레드보다 많은 메모리 공간과 cpu 시간을 차지한다.</li>\n<li>멀티 스레드 환경에서는 <code class=\"language-text\">동기화 문제</code>나 하나의 쓰레드가 장애가 날 경우 전체 스레드가 종료될 위험이 있다.</li>\n<li>멀티 프로세스의 경우에는 하나의 프로세스가 죽어도 다른 프로세스의 영향을 주지 않아 안정성이 높다.</li>\n</ul>\n<h2 id=\"언제-무엇을-사용해야하는가\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"언제 무엇을 사용해야하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용해야하는가?</h2>\n<p>메모리 구분이 필요할 때는 멀티 프로세스가 유리합니다. 반면에 컨텍스 스위칭이 자주 일어나고, 데이터 공유가 빈번한 경우, 그리고 자원을 효율적으로 사용해야하는 경우에 멀티 스레드를 사용하는 것이 유리해요</p>\n<h2 id=\"멀티-프로세스-환경에서-프로세스간에-데이터를-어떻게-주고-받는-법\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EB%B2%95\" aria-label=\"멀티 프로세스 환경에서 프로세스간에 데이터를 어떻게 주고 받는 법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 환경에서 프로세스간에 데이터를 어떻게 주고 받는 법</h2>\n<p>원칙적으로는 독립적인 주소 공간을 가지고 있기 때문에 다른 프로세스의 주소 공간을 참조할 수 없다. 하지만 경우에 따라 운영체제는 프로세스 간의 자원 접근을 위한 매커니즘인 프로세스 간 통신(IPC, Inter Process Communication) 을 제공합니다.</p>\n<h3 id=\"ipc\" style=\"position:relative;\"><a href=\"#ipc\" aria-label=\"ipc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IPC</h3>\n<p>기본적으로 공유 메모리와 메시지 전달 두가지 모델이 있습니다.</p>\n<h3 id=\"공유-메모리\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"공유 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공유 메모리</h3>\n<p>공유 메모리 방식에서는 <code class=\"language-text\">프로세스들이 주소 공간의 일부를 공유</code>해요.  공유한 메모리 영역에 읽기 쓰기를 통해서 통신을 수행합니다.\n프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해주어요. 공유 메모리 영역이 구축된 이후에는  모든 접근이 일반적인 메모리 접근으로 취급되기 때문에 더이상 커널의 도움 없이도 각 프로세스들이 해당 메모리 영역에 접근 할 수 있어요. 하지만 일관성 문제가 발생할 수도 있습니다. 이에 대해서는 커널이 관여하지 않기 때문에 프로세스들 끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+klEQVQoz2WSbVMaMRSFs2/AygJaoXZxN5uXXUClo7RUKm21tePg1Bn//795OonIYPvhzM2H5Mm95x6xvL7mz/Mzvx4euFwsKMsSrbWXlCVpkhAJQRQIOkmMLAu0Niil/B1X98/i03LJ1/Wa1c0Nl1dXby9ISRKF9Pt9sl6POAz+A+30CvyyWvHt9paVg67XaGPeAF1XvSwj6x7QCgPs7Aw7maKqCq3Vbhq9BYuiKCjGY4px7qtxsC3Qjd+KYwIhCIUgcR02U5rzCw9UxiCVQm7PHmitYTjoMzwc8PFsRieOKPMcay3uMxEECCF2qhzwYk6lFO1uRl6U6LohbqeUSiOs0Rz3uxxmB0yMohMHyPyDB7oO4yQiDAPCKCSKQsz5HDuZeM9aWY9hnnOqFFG6BRoHPOphjeTqcs7weMB4/J66rinKgsN3fbRVVKrkaHRMvVhijEWqimyQ0UwbZuczfy5kgXBeVcWYIj9h1ljykxFalhj94k+72yVut71aaUplLNPFZ4zzzxh0XTObz8nL0vsopJT8uPvJ5unJ6/dmQ9NMvMEOGMYJo9GI0XBIEMW+w9pt2hoeHh+5u7/39fvtHXXTvHToH0tJ5ba1l0O3vVZ64EFOSSelsvUuIs5j9+6llv692OXonzy9xibc27KLT3F66sd9vbMvF5u/iKwlgSYqcuAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"7.png\"\n        title=\"7.png\"\n        src=\"/static/95dd8457ce7bbd731ad495f84798d0b5/37523/7.png\"\n        srcset=\"/static/95dd8457ce7bbd731ad495f84798d0b5/e9ff0/7.png 180w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/f21e7/7.png 360w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/37523/7.png 720w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/d30ee/7.png 980w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"메시지-전달\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC\" aria-label=\"메시지 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 전달</h2>\n<p>통상 system call 을 사용하여 구현 되어요. 커널을 통해 샌드와 리시버 라는 두가지 연산을 제공 받는다. 예를 들면, 프로세스1이 커널로 메세지를 보내면 커널이 프로세스 2에게 메세지를 보내주는 방식으로 동작합니다. 메모리 공유 보다는 속도가 느리지만, 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용하다. 또 구현하기 쉽다는 장점이 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABaklEQVQoz6WSe2vCMBTFo87W9MUEBZ21ebRat9WW6TaYD9aJw0Fhj+//Yc5ItMNuDBz74+Qm3Jsf54SQJE2xXK+xKwo8bbcIggCcczDOEQoBetYENU2cux6eX16Q7woMuYAQApwxPVuKMQZyM5+jeHvFOs+xWK0gpdRNdUHJphQ1QtAgNRBC4IcjXM7vMUrS/czRrLpHoijCdZIgnkx0LYFKoRRwLYpmo4GW0YRjWxCMYZzNIMexhiqXFaBaVExllx3ils1ISrQMA67nwfM8FB/veNxs4A8DRPEEo2kGzoIqsDwcq3QopYDn2KiryPV95ItuB+E4Rjy7hfj2PL8DD00ZhrBcFy1KQamFqzRD+rBENM10j3P2BToRGMGklo7cbrexyHPc5Rv4gwGE4JU0J0VWe2o7Oiqp13XtdjoItbsq6GSgaRgapL6Oqv1+v/K1/uzQOABL9Xq9/wHV2zmOA9d1dfV9/0fMY+An4wsprBnVZbQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8.png\"\n        title=\"8.png\"\n        src=\"/static/e64db8d1e895868abd91f33690602dd8/37523/8.png\"\n        srcset=\"/static/e64db8d1e895868abd91f33690602dd8/e9ff0/8.png 180w,\n/static/e64db8d1e895868abd91f33690602dd8/f21e7/8.png 360w,\n/static/e64db8d1e895868abd91f33690602dd8/37523/8.png 720w,\n/static/e64db8d1e895868abd91f33690602dd8/91f10/8.png 992w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-프로세스-스레드-환경에서-동기화-문제를-어떻게-해결하나요\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"멀티 프로세스 스레드 환경에서 동기화 문제를 어떻게 해결하나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스/ 스레드 환경에서 동기화 문제를 어떻게 해결하나요?</h2>\n<p>동기화문제를 해결하기 위해 뮤텍스와 세마포어 기법을 사용할 수 있어요. 뮤텍스란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법입니다. 공유 자원을 점유하는 스레드가 락을 걸게 됩니다. acquire 함수를 사용하여 Lock 을 획득하고 release 함수가 Lock 를 반환해요.</p>\n<p>이때 락이 안풀리는데 계속 접근하고 취소하는 등 하는 부분을 busy waiting 이라고 하는데 다른 프로세스/스레드가 생산적으로 사용할 수 있는 CPU 를 낭비한다는 단점이 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACfElEQVQoz1WTy08TURTGp2DBmgCJ0xba6WOe996ZtjPThxofxTexiFi3rtmz8BVNXCoIvjEiUSNu1H9B92z5l35mpkJkcXLuPcn9zjnf913NsiziTod2t4tpmiT3JJJz3axjGAaGUcY062ntoF4qlchkMmiadhiVSgWt1WpxYzAgbrep1+spWPIgycKRXL5wlYXLA6KgQ6hiWjKkoRpIJRkbHz8CmDTXVlZW+PXzB/35c8yV5rBtCyV8Wn6McBTv322xu7uL7/vYrkSqkF6vz+1bd9GnZyhMzzCn60yOZTBrVbThnTtsrr/Ac1zOnr5AJ+7gywZSSvS8ztrac7Y/7VCzFTKIsD2FqwIuXV+kG52hohsYVkguN0XFKKENbw/Z+fgZ1xJc6V+j1+3hCQ9PCHRdZ3Nzg89fv5EvFPFcF9/zCVVE1IoxLZfsRJaZos14dpJyuYw2HA7Z3trBEy7n++dpNpspWBLFQpHXm2/4/uU7TtWlqSKUFyA8wezsLNnsOHXbY6ZooWWOpeKlgB+3tvFswbX5BcIwwnUEnbBHtVzn1cZb1p89x7RqxHEbP/BxHAfTspnMTTNbcXH8mOO53GjCpaUl/vz5TTvq0G51UcrH9wM8zyOvn2R94xX3HjzCdALO9BdotmL8ZgdXNpk4PkWhbDFnVJmYnBipPBgM2NvbI2gEGBXj0IO27VAo5Fl78ZL7Dx+jpGB+vk8UhkilsBzBiak82tixoz5cXl5mf38/5a5Wqx0aO1krn9d58+4Dj588RaoG/YtXEGKktiuCQ2Mf5BSw2+2yuro64uXfTxlNaKecLC7eJNlCBjGnzl5KKRFSUqtVyfxn6gPAv4UbVfX3Dye/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9.png\"\n        title=\"9.png\"\n        src=\"/static/e8ec8624b1b24871d474abe756f3f5cd/37523/9.png\"\n        srcset=\"/static/e8ec8624b1b24871d474abe756f3f5cd/e9ff0/9.png 180w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/f21e7/9.png 360w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/37523/9.png 720w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/1568e/9.png 892w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>세마포어는 S개의 스레드만이 공유 자원에 접근할 수 있도록 제어하는 동기화 기법입니다. 세마포어 기법에서는 정수형 변수 값을 가용한 자원의 수로 초기화하고, 자원에 접근할 때는 S— 연산을 수행하여 세모포 값을 감소시키고 자원을 방출할 때는 S++ 연산을 수행하여 세바포 값을 증가 시킴. 이때 값이 0이 되면 모든 자원이 사용중이다.라고 인식하고, 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 Block 됩니다.</p>\n<p>바이너리 세마포어라고 값이 0, 1만 가질 수 있는 경우, 바이너리 세마포어라고 하는데 이는 뮤텍스랑 거의 유사하게 작동한다고 보면 됩니다.</p>\n<h2 id=\"교착-상태deadlock-란\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9Cdeadlock-%EB%9E%80\" aria-label=\"교착 상태deadlock 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착 상태(Deadlock) 란?</h2>\n<p>둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말해요.\n데드락이 발생하는 조건은 상호 배제, 점유 대기, 비선점, 순환대기 이 네가지 조건이 동시에 성립할 때 발생할 수 있어요.</p>\n<ol>\n<li>상호 배제\n<ul>\n<li>동시에 한 스레드만 자원을 점유할 수 있는 상황</li>\n<li>다른 스레드가 자원을 사용하려면 자원이 방출될 때까지 기다려야한다.</li>\n</ul>\n</li>\n<li>점유 대기\n<ul>\n<li>스레드가 자원을 보유한 상태에서 다른 스레드가 보유한 자원을 추가로 기다리는 상황</li>\n</ul>\n</li>\n<li>비선점\n<ul>\n<li>다른 스레드가 사용중인 자원을 강제로 선점할 수 없는 상황이다.</li>\n<li>자원을 점유하고 있는 스레드에 의해서만 자원이 방출된다.</li>\n</ul>\n</li>\n<li>순환대기\n<ul>\n<li>대기 중인 스레드들이 순환형태로 자원을 대기하고 있는 상황이다.</li>\n</ul>\n</li>\n</ol>\n<p>해결 방법은 무시, 예방, 회피, 탐지-회복의 4가지 방법이 있다.</p>\n<ol>\n<li>무시\n<ul>\n<li>데드락이 발생할 확률이 낮으면 무시하는 것이다.</li>\n</ul>\n</li>\n<li>예방\n<ul>\n<li>교착상태 4가지 발생 조건 중 하나가 성립하지 않게 막는 방법이다.</li>\n<li>자원 사용의 효율성이 떨어지고, 비용이 크다.</li>\n</ul>\n</li>\n<li>회피\n<ul>\n<li>스레드가 앞으로 자원을 어떻게 요청할지에 대한 정보를 통해 순환 대기 상태가 발생하지 안호록 자원을 할당하는 방법이다.</li>\n<li>은행원 알고리즘이 쓰임</li>\n</ul>\n</li>\n<li>탐지 - 회복\n<ul>\n<li>시스템 검사를 통해 데드락 발생을 탐지하고, 이를 회복 시키는 방법이다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href=\"https://learn-news.info/2\">CPU</a></li>\n<li><a href=\"https://www.dell.com/support/kbdoc/ko-kr/000148441/%EB%A9%94%EB%AA%A8%EB%A6%AC-ram-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C\">RAM</a></li>\n</ul>\n<h2 id=\"대답해보면-좋을-항목\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EB%8B%B5%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%84-%ED%95%AD%EB%AA%A9\" aria-label=\"대답해보면 좋을 항목 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대답해보면 좋을 항목</h2>\n<ul>\n<li>프로세스를 간단히 설명해주세요</li>\n<li>프로세스의 메모리영역(code, data, stack, heap) 에 대해서 설명해주세요</li>\n<li>멀티 프로세스에 대해서 설명해주세요</li>\n<li>프로세스의 컨텍스트는 무엇인가요?</li>\n<li>Process Control Block 에 저장되는 것들은 무엇이 있나요?</li>\n<li>프로세스의 상태에는 어떤 것들이 있나요?</li>\n<li>멀티 쓰레드가 멀티 프로세스보다 좋은점은 무엇인가?</li>\n<li>멀티 프로세스가 멀티 스레드보다 안좋은 점은 무엇인가?</li>\n</ul>","excerpt":"프로세스와 스레드를 학습하기에 앞서, 이해하고 있으면 좋은 개념인 CPU 와 RAM 에 대해서 간단히 알아보아요! ☺️ CPU란? (core processing unit) 중앙 처리 장치로 컴퓨터를 통한 연산과 수행, 프로그램 실행을 담당하고 있어요\nCPU 는 출력을 전달하기 전에 RAM 에서 입력을 가져와 명령문을 이해하고 처리합니다. RAM란?(Random access memory) 프로그램이 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리 RAM 이란 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스할 수 있는 데이터 저장소입니다. 데이터를 가져오기, 디코딩, 실행이 세가지가 cpu 의 핵심이자 전부에요! 프로세스(Process) 프로세스란 실행중인 프로그램을 뜻합니다. 즉, 파일 형태로 존재하던 프로그램이 메모리에 적재되어 CPU 에 의해 실행되는 것을 Process 라고 합니다. 메모리에 적재 메모리는 CPU가 직접 접근 할 수 있는 컴퓨터 내부의 기억 장치 입니다. …","frontmatter":{"date":"December 21, 2022","title":"프로세스와 스레드","categories":"cs","author":"수달","emoji":"🙂"},"fields":{"slug":"/os/process_vs_thread/"}},"next":{"id":"9570951e-8b80-5559-bcbb-b9ea3f132834","html":"<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>정렬 알고리즘에 대해서 공부하다가 Arrays.sort 내부 구현체는 Comparable 을 상속받아 구현되어 있다는 내용을 알게 되었습니다.  Comparable 의 특징과 동작원리를 알게되면 더욱 효과적으로 사용할 수 있을 것 같아서 읽게 되었어요.</p>\n<h2 id=\"comparable\" style=\"position:relative;\"><a href=\"#comparable\" aria-label=\"comparable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparable</h2>\n<p>자바에서 제공되는 정렬이 가능한 클래스들은 모두 Comparable 인터페이스를 구현하고 있으며, 정렬 시에 이에 맞게 정렬이 수행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Integer Class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Integer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// String Class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>Integer 와 Double 클래스는 숫자 오름차순으로 정렬되어 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>String은  A-Z, 1-9 같이 사전순으로 정렬되어 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> anotherString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span> v1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">byte</span> v2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> anotherString<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">coder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> anotherString<span class=\"token punctuation\">.</span><span class=\"token function\">coder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">isLatin1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token class-name\">StringLatin1</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span>\n                              <span class=\"token operator\">:</span> <span class=\"token class-name\">StringUTF16</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">isLatin1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token class-name\">StringLatin1</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareToUTF16</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span>\n                          <span class=\"token operator\">:</span> <span class=\"token class-name\">StringUTF16</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareToLatin1</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"유일무이한-메서드-compareto\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%9D%BC%EB%AC%B4%EC%9D%B4%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-compareto\" aria-label=\"유일무이한 메서드 compareto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유일무이한 메서드 compareTo</h3>\n<p>해당 인터페이스에는 메서드가 compareTo 딱 하나뿐이에요. 이 compareTo 를 재정의해서 정렬 조건을 사용할 의도에 맞춰서 변경할 수 있어요!</p>\n<ul>\n<li>비교 값이 0 이면 같다.</li>\n<li>비교 값이 1 (양수) 이면 크다.</li>\n<li>비교 값이 -1 (음수) 이면 작다.</li>\n</ul>\n<p><code class=\"language-text\">기본 값은 오름차순</code> 정렬이고, 비교군을 반대로 한다면 내림차순으로 정의할 수도 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>other o1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> o1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">-</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id \n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"compareto-와-equals-의-차이가-뭐지\" style=\"position:relative;\"><a href=\"#compareto-%EC%99%80-equals-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%90%EC%A7%80\" aria-label=\"compareto 와 equals 의 차이가 뭐지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>compareTo 와 Equals 의 차이가 뭐지?</h3>\n<p>가장 큰 차이는 비교 타입이 달라도 된다는 것입니다. equals 는 비교하는 타입이 같아야 하지만, compareTo는  보통 비교할 객체들이 구현한 공통 인터페이스를 매개로 전달받아 비교를 진행하게됩니다. 또한 compreTo 는 단순 동치성 비교에 더해 순서 비교까지 할 수 있으며 제네릭합니다.</p>\n<blockquote>\n<p>동치성이란 같다는 의미로 동등성과도 거의 같은 의미로 쓰이는 것 같아요. 두 개의 객체가 같은 정보를 가지고 있는 경우를 의미합니다.</p>\n</blockquote>\n<h3 id=\"compareto-규칙\" style=\"position:relative;\"><a href=\"#compareto-%EA%B7%9C%EC%B9%99\" aria-label=\"compareto 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>compareTo 규칙</h3>\n<ul>\n<li>두 객체의 참조 순서를 바꿔도 예상한 결과가 나와야한다.</li>\n<li>반사성, 대칭성, 추이성을 지켜야한다.</li>\n</ul>\n<h3 id=\"권고-사항\" style=\"position:relative;\"><a href=\"#%EA%B6%8C%EA%B3%A0-%EC%82%AC%ED%95%AD\" aria-label=\"권고 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>권고 사항</h3>\n<p>compareTo 로 실행한 결과가 equals 결과와 같게 하면 좋아요. 물론 결과가 일관되지 않은 compareTo 도 여전히 동작은 하지만, 인터페이스(Set, Map) 동작과 다르게 동작할 수도 있어요. 이 인터페이스는 equals 를 기반으로 동작한다고 되어 있지만, 놀랍게도 정렬된 컬렉션들은 동치성을 비교할 때 compareTo 를 사용하기 때문이에요.</p>\n<ul>\n<li>BigDecimal 타입 같은 경우는 내부에서 compareTo 와 equals 를 다른 기준으로 재정의 해두었어요. 그래서 해당 컬렉션에서 정렬을 하게되면 일관되지 못한 반환값이 나올거에요 ㅠㅠ</li>\n</ul>\n<h3 id=\"클래스에-구현한-compareto\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EA%B5%AC%ED%98%84%ED%95%9C-compareto\" aria-label=\"클래스에 구현한 compareto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스에 구현한 compareTo</h3>\n<p>클래스에 핵심 필드가 여러개라면 어느 것을 먼저 비교하냐가 중요해져요. 가장 핵심 필드부터 비교하세요! 비교 결과가 0이 아니라면 즉시 반환하면 됩니다. 거기서 순서가 바로 정해졌기 때문이죠 ㅎ</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span> pn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>areaCode<span class=\"token punctuation\">.</span>areaCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">.</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">.</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자바8 부터는 Comparator 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성할 수 있게 되었어요. 그러나 이 방식은 약간의 성능 저하가 뒤따릅니다. 아 추가로 자바의 정적 임포트 기능을 이용하면 그 이름만으로 사용할 수 있어 코드가 훨씬 깔끔해집니다 ☺️</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">C</span> <span class=\"token operator\">=</span>\n\t\t\t<span class=\"token function\">comparingInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span> pn<span class=\"token punctuation\">)</span> pn<span class=\"token punctuation\">.</span>areaCode<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">thenComparingInt</span><span class=\"token punctuation\">(</span>pn <span class=\"token operator\">-></span> pn<span class=\"token punctuation\">.</span>prefix<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">thenComparingInt</span><span class=\"token punctuation\">(</span>pn <span class=\"token operator\">-></span> pn<span class=\"token punctuation\">.</span>lineNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 엄청 간결!</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">.</span><span class=\"token function\">compre</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>pn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드는 람다를 인수로 받으며 위에는 조건 분기문을 계속 만들었지만, 여기서는 thenComparingInt(조건 함수)를 사용하여 <code class=\"language-text\">분기문을 줄이고</code> 하나의 메소드를 재사용하여 여러 조건으로 비교하여 순서를 결정할 수 있게 되었습니다. 훨씬 간결해졌죠?! 타입 또한 최초 한번은 타입을 명시해주고, 그 뒤에서부터는 자바에서 알아서 추론이 가능해집니다.</p>\n<h3 id=\"해시-코드-값으로-비교는-금물\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%EC%BD%94%EB%93%9C-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%B9%84%EA%B5%90%EB%8A%94-%EA%B8%88%EB%AC%BC\" aria-label=\"해시 코드 값으로 비교는 금물 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 코드 값으로 비교는 금물!!!</h3>\n<p>이 방식은 정수 오버 플로를 일으키거나 IEEE 754 부동소수점 계산방식에 따른 오류를 낼 수 있어요</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compre</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> o1<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> o2<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"간단한-사용-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"간단한 사용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 사용 방법</h2>\n<ul>\n<li>Arrays.sort(array);</li>\n<li>Collections.sort(list);</li>\n</ul>\n<h3 id=\"타입에-따른-arrayssort-의-신기한-내부-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%97%90-%EB%94%B0%EB%A5%B8-arrayssort-%EC%9D%98-%EC%8B%A0%EA%B8%B0%ED%95%9C-%EB%82%B4%EB%B6%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"타입에 따른 arrayssort 의 신기한 내부 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입에 따른 Arrays.sort() 의 신기한 내부 알고리즘</h3>\n<ul>\n<li>\n<p>double[], int[] 등 Object Arrays 에서는 <code class=\"language-text\">TimSort</code> 를 사용한다.</p>\n<p>Merge Sort 와 Insertion Sort 를 사용합니다 ㅎㅎ</p>\n</li>\n<li>\n<p>새로 정의한 클래스 배열은 <code class=\"language-text\">Dual PivotQuicSort</code>를 사용한다.</p>\n<p>DualPivotQuicSort 는 Quick sort + insertion sort 를 사용해요.</p>\n</li>\n<li>\n<p><code class=\"language-text\">List Collection</code>의 경우 <code class=\"language-text\">내부적으로 Arrays.sort</code> 를 사용하고 있어요.</p>\n</li>\n</ul>\n<h2 id=\"comparator-랑-차이가-뭔데\" style=\"position:relative;\"><a href=\"#comparator-%EB%9E%91-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%94%EB%8D%B0\" aria-label=\"comparator 랑 차이가 뭔데 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparator 랑 차이가 뭔데?</h2>\n<p>기본 정렬 기준과 다르게 정렬하고 싶을 때 사용하는 인터페이스 입니다. 내부에 내림차순 정렬이나 다양한 조건의 정렬이 구현되어 있습니다.</p>\n<h3 id=\"사용-방법\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"사용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 방법</h3>\n<p>Compareator 내부에 선언되어 있는 정적 메서드를 호출해서 정렬시 조건문을 넣어주는 매개변수에 전달하면 됩니다. ☺️</p>\n<h2 id=\"정리-\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-\" aria-label=\"정리  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리 💪🏻</h2>\n<p>순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야한다 compareTo 메서드에서 필드의 값을 비교할 때 and 연산자는 쓰지말자. 그대신 박싱된 기본 타입 클래스가 제공하는 정적메서드 compare 이나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.</p>\n<h2 id=\"느낀점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\"느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀점</h2>\n<p>자바에서 기본적으로 제공하는 기능들을 가져다 사용하는 것 뿐만 아니라 내부 구현과 그 구현에 시간복잡도, 구현 알고리즘을 살펴보니 같은 기능이더라도 구현 방식이 달라서 효율성을 따져 볼 때 좋은 선택 기준이 될 것 같아요.</p>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li>구현체 코드</li>\n<li><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#:~:text=emptyMap()-,Method%20Detail,-sort\">Collections.sort javadoc</a></li>\n<li><a href=\"https://gmlwjd9405.github.io/2018/09/06/java-comparable-and-comparator.html\">comparable 과 Comparator 차이 블로그 글</a></li>\n</ul>","frontmatter":{"date":"December 16, 2022","title":"[Effective Java -14장] Comparable 을 구현할지 고려해라","categories":"cs 개발독서","author":"수달","emoji":"🙂"},"fields":{"slug":"/java/Comparable/"}},"prev":{"id":"62cd453a-3ed8-599d-9371-3607bdaa920d","html":"<blockquote>\n<h2 id=\"msamicro-service-architecture란-\" style=\"position:relative;\"><a href=\"#msamicro-service-architecture%EB%9E%80-\" aria-label=\"msamicro service architecture란  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSA(Micro Service Architecture)란 ?</h2>\n</blockquote>\n<p><code class=\"language-text\">시스템을 여러개의 독립된 서비스(기능)로 나눠서, 이 서비스를 조합함으로서 기능을 제공하는 아키텍처</code> 디자인 패턴입니다. 완전히 독립적으로 배포가 가능하기 때문에 다른 기술 스택을 사용할 수 있어요.</p>\n<h3 id=\"모놀리식-구조monolithic-architecure\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EA%B5%AC%EC%A1%B0monolithic-architecure\" aria-label=\"모놀리식 구조monolithic architecure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모놀리식 구조(Monolithic Architecure)</h3>\n<p><code class=\"language-text\">하나의 프로그램안에 모든 기능이 있는 통합되어 있는 형태</code>를 말합니다. 관리가 쉬우며 초기 배포 단계에 설정할 것이 많지 않아서 MSA 보다 비교적 간단하게 서버 운영이 가능합니다. :)</p>\n<h3 id=\"모놀리식-구조-문제점\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EA%B5%AC%EC%A1%B0-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"모놀리식 구조 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모놀리식 구조 문제점</h3>\n<ul>\n<li>\n<p><strong>부분 장애가 전체 서비스 장애로 이어진다.</strong></p>\n<p>모놀리식 구조를 가진 프로젝트를 했을 당시,  회원 가입 로직에서 문제가 생겨 서버가 다운된 적이 있습니다.  <code class=\"language-text\">개발자의 잘못된 코드</code> 혹은 갑자기 트래픽 증가로 인해서 성능에 문제가 생겼을 때, 서비스 전체의 장애로 확대될 수 있어요.</p>\n</li>\n<li>\n<p><strong>부분적인 scale-out 이 어렵다.</strong></p>\n<p>회원 가입은 부하가 자주 일어나지 않지만, 상품 주문은 빈번히 일어나는 작업이죠! 이럴 경우 더 많은 트래픽을 감당할 수 있는 인프라 구조가 필요한데요. 모놀리식 구조의 경우 서버를 나누어 처리할 수 없기 때문에 <code class=\"language-text\">부분적인 스케일 관리가 어렵습니다.</code></p>\n</li>\n<li>\n<p><strong>서비스의 변경이 어렵고, 수정시 장애의 영향 파악이 어렵다.</strong></p>\n<p>여러 기능이 하나의 프로젝트 내부에 있다보면 의존성이 강하게 엮어있어서 장애 포인트를 찾기 어려웠던 경험이 있어요. 그래서 이런 부분을 <a href=\"https://www.youtube.com/watch?v=dJ5C4qRqAgA&#x26;t=1617s\">조영호님의 우아한 객체지향 영상</a>을 보며 조금이나마 해소하고자 했었는데요. 이런 문제가 발생하는 이유는 하나의 프로젝트에 여러 기능들이 있기 때문이기에 MSA 로 전환한다면 해당 문제를 조금이나마 해소할 수 있을 거에요.</p>\n</li>\n<li>\n<p><strong>배포 시간이 오래걸린다.</strong></p>\n<p>작은 기능임에도 불구하고 프로젝트 규모가 커 테스트 실행시간, 배포 시간이 많이 드는 경험을 한 적이 있어요. 기능별로 분리하면 테스트 코드 개수도 감소하고, 배포 파일 크기도 감소하기 때문에 <code class=\"language-text\">CI/CD 속도도 훨씬 빨라질거예요!</code></p>\n</li>\n</ul>\n<h3 id=\"msa-등장-배경\" style=\"position:relative;\"><a href=\"#msa-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD\" aria-label=\"msa 등장 배경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSA 등장 배경</h3>\n<p>이러한 <code class=\"language-text\">모놀리식 구조의 문제점들을 보완하기 위해 MSA가 등장</code>하게 되었답니다. 기존에 특정 물리 서버에 서비스를 올리던 on-promise 서버 기반의 모놀리식에서 이제는 클라우드 환경을 이용하여 서버를 구성하는 MSA 로 많은 서비스들이 전환되고 있어요.</p>\n<blockquote>\n<h2 id=\"msa-특징\" style=\"position:relative;\"><a href=\"#msa-%ED%8A%B9%EC%A7%95\" aria-label=\"msa 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSA 특징</h2>\n</blockquote>\n<p><code class=\"language-text\">API 를 통해서만 상호작용</code>을 할 수 있어요.  서비스 끼리 end-point 를 API 형태로 외부에 노출하고, 실질적인 세부 사항은 모두 추상화 합니다.</p>\n<ul>\n<li><code class=\"language-text\">하나의 기능만 수행</code>합니다. 여러 어플리케이션에서 서비스를 호출하여 상호작용할 수 있습니다.</li>\n<li>프로토콜을 사용해 통신하므로 서비스 <code class=\"language-text\">구현 기술을 다양하게 사용</code>할 수 있습니다.</li>\n<li>집중화된 관리 체계를 사용하지 않아요. ESB(Enterprise Sevice Bus)와 같은 무거운 제품에 의존하지 않고, <code class=\"language-text\">REST 등 가벼운 통신 아키텍처, 또는 카프카 등을 이용한 메세지 스트림을 주로 사용</code>합니다.</li>\n<li><code class=\"language-text\">독립적인 배포</code>가 가능해요!</li>\n<li><code class=\"language-text\">개별적인 scale-out 이 가능</code>해요. 메모리, CPU적으로도 상당부분 이득이 됩니다.</li>\n</ul>\n<blockquote>\n<h2 id=\"mas-단점\" style=\"position:relative;\"><a href=\"#mas-%EB%8B%A8%EC%A0%90\" aria-label=\"mas 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MAS 단점</h2>\n</blockquote>\n<ul>\n<li>\n<p><code class=\"language-text\">많이 복잡해요.</code> 서비스가 분산되어 있기 때문에 내부 서비스 통신을 어떻게 가져가야할지 정해야하고, 또 통신 장에나 서버 부하가 있을 경우 트랜잭션 관리에 대해서도 고민할 점이 많아요.</p>\n<p>모놀리식에서는 단일 트랜잭션을 유지하면 됐지만, <code class=\"language-text\">MSA</code> 에서는 비지니스에 대한 DB 를 가지고 있는 서비스도 각기 다르고 서비스 연결을 위해서는 통신이 포함되기 때문에 <code class=\"language-text\">트랜잭션을 유지하는게 어렵습니다.</code></p>\n</li>\n<li>\n<p>통합테스트가 어렵다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것이 쉽지 않아요.</p>\n</li>\n<li>\n<p><code class=\"language-text\">단일 서비스를 배포하더라도, 다른 서비스들과 연계가 정상적으로 이뤄지고 있는지도 확인</code>해야합니다.</p>\n</li>\n</ul>\n<h2 id=\"모놀리식-vs-msa\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-vs-msa\" aria-label=\"모놀리식 vs msa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모놀리식 vs MSA</h2>\n<p>다양한 기술 스택을 사용하고, 메모리 관리가 용이하고,  단일 장애가 전체 시스템에 영향을 주면 안되는 상황들은 보통 대규모 서비스를 운영할 때 필요할 것 같아요.\n보통 서비스 유저가 1000명 정도 되는 서비스에서는 MSA 의 장점을 취하지 충분히 운영이 가능했었거든요. 서비스가 점점 커지면 각 도메인간 의존성이 늘어나고, PR 단위에서 많은 충돌이 발생하고, 배포하는데도 오래걸렸던 경험이 있어요. 이런 문제들을 해소하기 위한 방법 중 하나인 MSA 를 학습하며 사용자가 많은 서비스를 운영해보면서 더 많은 고민들을 하면 재밌겠다고 생각하게 된 계기가 되었습니다.</p>\n<blockquote>\n<h2 id=\"msa-에서-궁금한-점들\" style=\"position:relative;\"><a href=\"#msa-%EC%97%90%EC%84%9C-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90%EB%93%A4\" aria-label=\"msa 에서 궁금한 점들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSA 에서 궁금한 점들</h2>\n</blockquote>\n<h3 id=\"어떻게-트랜잭션-관리를-할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EB%A6%AC%EB%A5%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 트랜잭션 관리를 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 트랜잭션 관리를 할까?</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    배달 시스템에서 주문을 한다고 가정하면 \n    - `결제를 시작하고`\n    - `쿠폰을 적용하고`\n    - `카드를 선택하고`\n    - `메뉴 주문이 가능한지 한번더 확인`\n    - `결제 완료`\n    - 배달 요청이 전송된다.</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">이 여러개의 작업 단위를 하나의 트랜잭션으로 묶어서 하나라도 제대로 된 처리가 되지 않으면 롤백하고 예외 처리를 해줘야하는데 이런 부분을 어떻게 하고 있을까?\n\n그동안 서비스 레이어를 작성하면서 API 요청은 하나만 들어오고 여러개의 행위를 수행했는데 이렇게 되면 </code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    \n    1)  결제를 시작한다. (api call)\n    \n    2) 쿠폰 사용가능한지 확인한다. \n    \n    2-1) 쿠폰 사용이 가능하면 사용 처리한다.\n    \n    3) 쿠폰 적용한 금액을 반환한다.\n    \n    4) 카드를 선택한다.\n    \n    5) 결제팀에서 결제 요청을 전송한다.\n    \n    A- 1) `결제가 취소`되었다.\n    \n    A-2) 결제가 실패되면 `쿠폰사용도 취소`한다 . \n    \n    ---\n    \n    B-1) `결제가 성공`했다.\n    \n    B-2) `결제 내역을 히스토리에 저장`한다.\n</code></pre></div>\n<p>이런 느낌으로 트랜잭션이 묶여야 할 것 같은데 이런걸 이벤트 처리로 하는건지\n아직 이벤트에 대한 학습이 부족해서 잘 모르겠네요 ㅠㅠ\n이 부분은 추가학습 한 뒤 내용을 덧붙여보겠습니다.</p>\n<blockquote>\n<h2 id=\"모놀리식-vs-msa-1\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-vs-msa-1\" aria-label=\"모놀리식 vs msa 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모놀리식 vs MSA</h2>\n</blockquote>\n<p>시스템의 규모가 작음에도 MSA 구조를 사용하는 것은 모든 요청마다 네트워크 비용이 추가되고, 서버 운영 비용도 추가되고,  테스트를 하기 어려워지고, 트랜잭션관리도 하기 힘들어지는 문제를 야기할 수 있어요. 그래서 대부분의 개발초기에서는 모놀리식 구조를 가지고 있다가 서비스가 커지면 MSA 전환을 고려하는 것 같아요 ㅎㅎ 각 구조의 트레이드 오프를 이해하고 사용해야겠습니다.</p>\n<blockquote>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n</blockquote>\n<ul>\n<li><a href=\"https://kkh1902.tistory.com/181\">MSA 란 무엇인가</a></li>\n</ul>","frontmatter":{"date":"December 21, 2022","title":"MSA(MicroService Architecture) 란 무엇인가","categories":"architecture","author":"수달","emoji":"🙂"},"fields":{"slug":"/design_pattern/"}},"site":{"siteMetadata":{"siteUrl":"https://her0807.com","comments":{"utterances":{"repo":"https://github.com/her0807/her0807.github.io"}}}}},"pageContext":{"slug":"/os/process_vs_thread/","nextSlug":"/java/Comparable/","prevSlug":"/design_pattern/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}