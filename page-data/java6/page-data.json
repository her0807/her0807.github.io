{"componentChunkName":"component---src-templates-blog-template-js","path":"/java6/","result":{"data":{"cur":{"id":"4e3535f2-4b48-5790-bde3-4f86100f2dec","html":"<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>정렬 알고리즘에 대해서 공부하다가 Arrays.sort 내부 구현체는 Comparable 을 상속받아 구현되어 있다는 내용을 알게 되었습니다.  Comparable 의 특징과 동작원리를 알게되면 더욱 효과적으로 사용할 수 있을 것 같아서 읽게 되었어요.</p>\n<h2 id=\"comparable\" style=\"position:relative;\"><a href=\"#comparable\" aria-label=\"comparable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparable</h2>\n<p>자바에서 제공되는 정렬이 가능한 클래스들은 모두 Comparable 인터페이스를 구현하고 있으며, 정렬 시에 이에 맞게 정렬이 수행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Integer Class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Integer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// String Class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Comparable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>Integer 와 Double 클래스는 숫자 오름차순으로 정렬되어 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>String은  A-Z, 1-9 같이 사전순으로 정렬되어 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> anotherString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span> v1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">byte</span> v2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> anotherString<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">coder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> anotherString<span class=\"token punctuation\">.</span><span class=\"token function\">coder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">isLatin1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token class-name\">StringLatin1</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span>\n                              <span class=\"token operator\">:</span> <span class=\"token class-name\">StringUTF16</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">isLatin1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token class-name\">StringLatin1</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareToUTF16</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span>\n                          <span class=\"token operator\">:</span> <span class=\"token class-name\">StringUTF16</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareToLatin1</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"유일무이한-메서드-compareto\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%9D%BC%EB%AC%B4%EC%9D%B4%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-compareto\" aria-label=\"유일무이한 메서드 compareto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유일무이한 메서드 compareTo</h3>\n<p>해당 인터페이스에는 메서드가 compareTo 딱 하나뿐이에요. 이 compareTo 를 재정의해서 정렬 조건을 사용할 의도에 맞춰서 변경할 수 있어요!</p>\n<ul>\n<li>비교 값이 0 이면 같다.</li>\n<li>비교 값이 1 (양수) 이면 크다.</li>\n<li>비교 값이 -1 (음수) 이면 작다.</li>\n</ul>\n<p><code class=\"language-text\">기본 값은 오름차순</code> 정렬이고, 비교군을 반대로 한다면 내림차순으로 정의할 수도 있어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>other o1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> o1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">-</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id \n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"compareto-와-equals-의-차이가-뭐지\" style=\"position:relative;\"><a href=\"#compareto-%EC%99%80-equals-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%90%EC%A7%80\" aria-label=\"compareto 와 equals 의 차이가 뭐지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>compareTo 와 Equals 의 차이가 뭐지?</h3>\n<p>가장 큰 차이는 비교 타입이 달라도 된다는 것입니다. equals 는 비교하는 타입이 같아야 하지만, compareTo는  보통 비교할 객체들이 구현한 공통 인터페이스를 매개로 전달받아 비교를 진행하게됩니다. 또한 compreTo 는 단순 동치성 비교에 더해 순서 비교까지 할 수 있으며 제네릭합니다.</p>\n<blockquote>\n<p>동치성이란 같다는 의미로 동등성과도 거의 같은 의미로 쓰이는 것 같아요. 두 개의 객체가 같은 정보를 가지고 있는 경우를 의미합니다.</p>\n</blockquote>\n<h3 id=\"compareto-규칙\" style=\"position:relative;\"><a href=\"#compareto-%EA%B7%9C%EC%B9%99\" aria-label=\"compareto 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>compareTo 규칙</h3>\n<ul>\n<li>두 객체의 참조 순서를 바꿔도 예상한 결과가 나와야한다.</li>\n<li>반사성, 대칭성, 추이성을 지켜야한다.</li>\n</ul>\n<h3 id=\"권고-사항\" style=\"position:relative;\"><a href=\"#%EA%B6%8C%EA%B3%A0-%EC%82%AC%ED%95%AD\" aria-label=\"권고 사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>권고 사항</h3>\n<p>compareTo 로 실행한 결과가 equals 결과와 같게 하면 좋아요. 물론 결과가 일관되지 않은 compareTo 도 여전히 동작은 하지만, 인터페이스(Set, Map) 동작과 다르게 동작할 수도 있어요. 이 인터페이스는 equals 를 기반으로 동작한다고 되어 있지만, 놀랍게도 정렬된 컬렉션들은 동치성을 비교할 때 compareTo 를 사용하기 때문이에요.</p>\n<ul>\n<li>BigDecimal 타입 같은 경우는 내부에서 compareTo 와 equals 를 다른 기준으로 재정의 해두었어요. 그래서 해당 컬렉션에서 정렬을 하게되면 일관되지 못한 반환값이 나올거에요 ㅠㅠ</li>\n</ul>\n<h3 id=\"클래스에-구현한-compareto\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EA%B5%AC%ED%98%84%ED%95%9C-compareto\" aria-label=\"클래스에 구현한 compareto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스에 구현한 compareTo</h3>\n<p>클래스에 핵심 필드가 여러개라면 어느 것을 먼저 비교하냐가 중요해져요. 가장 핵심 필드부터 비교하세요! 비교 결과가 0이 아니라면 즉시 반환하면 됩니다. 거기서 순서가 바로 정해졌기 때문이죠 ㅎ</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span> pn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>areaCode<span class=\"token punctuation\">.</span>areaCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">.</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresult <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">,</span> pn<span class=\"token punctuation\">.</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자바8 부터는 Comparator 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성할 수 있게 되었어요. 그러나 이 방식은 약간의 성능 저하가 뒤따릅니다. 아 추가로 자바의 정적 임포트 기능을 이용하면 그 이름만으로 사용할 수 있어 코드가 훨씬 깔끔해집니다 ☺️</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Comparator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">C</span> <span class=\"token operator\">=</span>\n\t\t\t<span class=\"token function\">comparingInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span> pn<span class=\"token punctuation\">)</span> pn<span class=\"token punctuation\">.</span>areaCode<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">thenComparingInt</span><span class=\"token punctuation\">(</span>pn <span class=\"token operator\">-></span> pn<span class=\"token punctuation\">.</span>prefix<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">thenComparingInt</span><span class=\"token punctuation\">(</span>pn <span class=\"token operator\">-></span> pn<span class=\"token punctuation\">.</span>lineNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 엄청 간결!</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">.</span><span class=\"token function\">compre</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>pn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드는 람다를 인수로 받으며 위에는 조건 분기문을 계속 만들었지만, 여기서는 thenComparingInt(조건 함수)를 사용하여 <code class=\"language-text\">분기문을 줄이고</code> 하나의 메소드를 재사용하여 여러 조건으로 비교하여 순서를 결정할 수 있게 되었습니다. 훨씬 간결해졌죠?! 타입 또한 최초 한번은 타입을 명시해주고, 그 뒤에서부터는 자바에서 알아서 추론이 가능해집니다.</p>\n<h3 id=\"해시-코드-값으로-비교는-금물\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EC%8B%9C-%EC%BD%94%EB%93%9C-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%B9%84%EA%B5%90%EB%8A%94-%EA%B8%88%EB%AC%BC\" aria-label=\"해시 코드 값으로 비교는 금물 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해시 코드 값으로 비교는 금물!!!</h3>\n<p>이 방식은 정수 오버 플로를 일으키거나 IEEE 754 부동소수점 계산방식에 따른 오류를 낼 수 있어요</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compre</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> o2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> o1<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> o2<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"간단한-사용-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"간단한 사용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 사용 방법</h2>\n<ul>\n<li>Arrays.sort(array);</li>\n<li>Collections.sort(list);</li>\n</ul>\n<h3 id=\"타입에-따른-arrayssort-의-신기한-내부-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%97%90-%EB%94%B0%EB%A5%B8-arrayssort-%EC%9D%98-%EC%8B%A0%EA%B8%B0%ED%95%9C-%EB%82%B4%EB%B6%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"타입에 따른 arrayssort 의 신기한 내부 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입에 따른 Arrays.sort() 의 신기한 내부 알고리즘</h3>\n<ul>\n<li>\n<p>double[], int[] 등 Object Arrays 에서는 <code class=\"language-text\">TimSort</code> 를 사용한다.</p>\n<p>Merge Sort 와 Insertion Sort 를 사용합니다 ㅎㅎ</p>\n</li>\n<li>\n<p>새로 정의한 클래스 배열은 <code class=\"language-text\">Dual PivotQuicSort</code>를 사용한다.</p>\n<p>DualPivotQuicSort 는 Quick sort + insertion sort 를 사용해요.</p>\n</li>\n<li>\n<p><code class=\"language-text\">List Collection</code>의 경우 <code class=\"language-text\">내부적으로 Arrays.sort</code> 를 사용하고 있어요.</p>\n</li>\n</ul>\n<h2 id=\"comparator-랑-차이가-뭔데\" style=\"position:relative;\"><a href=\"#comparator-%EB%9E%91-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%94%EB%8D%B0\" aria-label=\"comparator 랑 차이가 뭔데 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparator 랑 차이가 뭔데?</h2>\n<p>기본 정렬 기준과 다르게 정렬하고 싶을 때 사용하는 인터페이스 입니다. 내부에 내림차순 정렬이나 다양한 조건의 정렬이 구현되어 있습니다.</p>\n<h3 id=\"사용-방법\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"사용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 방법</h3>\n<p>Compareator 내부에 선언되어 있는 정적 메서드를 호출해서 정렬시 조건문을 넣어주는 매개변수에 전달하면 됩니다. ☺️</p>\n<h2 id=\"정리-\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-\" aria-label=\"정리  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리 💪🏻</h2>\n<p>순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야한다 compareTo 메서드에서 필드의 값을 비교할 때 and 연산자는 쓰지말자. 그대신 박싱된 기본 타입 클래스가 제공하는 정적메서드 compare 이나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.</p>\n<h2 id=\"느낀점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\"느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀점</h2>\n<p>자바에서 기본적으로 제공하는 기능들을 가져다 사용하는 것 뿐만 아니라 내부 구현과 그 구현에 시간복잡도, 구현 알고리즘을 살펴보니 같은 기능이더라도 구현 방식이 달라서 효율성을 따져 볼 때 좋은 선택 기준이 될 것 같아요.</p>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li>구현체 코드</li>\n<li><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#:~:text=emptyMap()-,Method%20Detail,-sort\">Collections.sort javadoc</a></li>\n<li><a href=\"https://gmlwjd9405.github.io/2018/09/06/java-comparable-and-comparator.html\">comparable 과 Comparator 차이 블로그 글</a></li>\n</ul>","excerpt":"학습 동기 정렬 알고리즘에 대해서 공부하다가 Arrays.sort 내부 구현체는 Comparable 을 상속받아 구현되어 있다는 내용을 알게 되었습니다.  Comparable 의 특징과 동작원리를 알게되면 더욱 효과적으로 사용할 수 있을 것 같아서 읽게 되었어요. Comparable 자바에서 제공되는 정렬이 가능한 클래스들은 모두 Comparable 인터페이스를 구현하고 있으며, 정렬 시에 이에 맞게 정렬이 수행됩니다. Integer 와 Double 클래스는 숫자 오름차순으로 정렬되어 있어요. String은  A-Z, 1-9 같이 사전순으로 정렬되어 있어요. 유일무이한 메서드 compareTo 해당 인터페이스에는 메서드가 compareTo 딱 하나뿐이에요. 이 compareTo 를 재정의해서 정렬 조건을 사용할 의도에 맞춰서 변경할 수 있어요! 비교 값이 0 이면 같다. 비교 값이 1 (양수) 이면 크다. 비교 값이 -1 (음수) 이면 작다.  정렬이고, 비교군을 반대로 한다면 내…","frontmatter":{"date":"December 16, 2022","title":"[Effective Java -14장] Comparable 을 구현할지 고려해라","categories":"cs 개발독서","author":"수달","emoji":"🙂"},"fields":{"slug":"/java6/"}},"next":{"id":"ef2f5533-0bce-52dd-86ee-87a658d3517f","html":"<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>평소에 목록을 저장하기 위해서 배열이나 List 자료 형을 썼었는데, 배열과 ArrayList 는 메모리 크기가 고정되어 있는지, 동적으로 커지는지에 차이가 있다고 생각되어 구분하여 잘 사용 했었습니다. 그런데 알고리즘을 풀면서 LinkedList 와는 잘 비교해서 사용하지 않았던 것 같아서 정리해보고자 합니다.</p>\n<h2 id=\"배열arrays\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4arrays\" aria-label=\"배열arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Arrays)</h2>\n<ul>\n<li>배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 자료구조에요</li>\n<li>Index 를 통해서 접근이 가능하고 0 번부터 시작합니다.</li>\n<li>최초 크기가 고정되면 바꿀 수 없어요.</li>\n</ul>\n<h3 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<ul>\n<li>조회는 접근하고자 하는 인덱스만 안다면 O(1) 시간이 걸려요.\n<ul>\n<li>순차 탐색시는 최대 O(n) 이 소모됩니다.</li>\n</ul>\n</li>\n<li>삽입 및 삭제\n<ul>\n<li>\n<p>배열의 <code class=\"language-text\">처음 또는 중간</code> 삽입, 삭제 O(n)</p>\n<p>삭제된 원소 뒤에 있는 원소들을 한칸씩 옮겨야 해서 O(n) 이 소모됩니다.</p>\n</li>\n<li>\n<p>배열의 <code class=\"language-text\">끝</code>에 삽입 및 삽입, 삭제  O(1)</p>\n<p>가장 뒤에는 옮길 원소가 없기 때문에 O(1) 이 소모됩니다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"사용하면-좋은-상황\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%83%81%ED%99%A9\" aria-label=\"사용하면 좋은 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용하면 좋은 상황</h3>\n<p>ArraysList 같은 경우는 메모리가 초과됐을 경우 특정 크기를 1.5배씩 증가 시키기 때문에 메모리 낭비가 있을 수 있어서 전체 원소의 메모리 사이즈를 알고 있다면 배열을 사용하는게 좋을 것 같아요.</p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>연결 리스트는 여러개의 노드가 순차적으로 연결된 형태를 가지는 자료구조이며, 첫번째 노드를 HEAD , 마지막 노드를 TAIL 이라고 합니다.</p>\n<h3 id=\"원형-linkedlist-node-구조\" style=\"position:relative;\"><a href=\"#%EC%9B%90%ED%98%95-linkedlist-node-%EA%B5%AC%EC%A1%B0\" aria-label=\"원형 linkedlist node 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원형 LinkedList Node 구조</h3>\n<ul>\n<li>data  와 Next node 주소값을 가져요.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Object</span> data<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>배열과 다르게 메모리를 연속적으로 사용하지 않아요!</li>\n<li>index 로 접근할 수 없기 때문에 순차 접근에는 분리할 수 있으나 노드가 연결된 구조이기 때문에 중간 삽입, 삭제시, 앞 뒤 노드만 연결해주면 되기 때문에 훨씬 효율적이에요!</li>\n</ul>\n<h3 id=\"시간-복잡도-1\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-1\" aria-label=\"시간 복잡도 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<ul>\n<li>조회에는 O(n) 시간이 소모됩니다.</li>\n<li>맨 앞 삽입,삭제 자체는 O(1) 이지만 중간 삽입,삭제는 탐색 시간이 소요되어 O(n) 이 걸려요.\n<ul>\n<li>연결리스트 맨 끝에 삽입할 때 만약 마지막 노드의 위치를 알고 있다면 O(1) 시간만으로도 해결할 수 있어요.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"삽입-flow\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85-flow\" aria-label=\"삽입 flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입 flow</h3>\n<ul>\n<li>노드를 생성하고, 삽입하려는 위치를 찾아요</li>\n<li>위치를 찾았으면, <code class=\"language-text\">삽입하려는 노드</code>가 그 위치에 <code class=\"language-text\">다음 노드를 가리키게</code> 합니다.</li>\n<li>삽입하려는 위치에 <code class=\"language-text\">이전 노드</code>는 <code class=\"language-text\">삽입 노드를 가리키게</code> 합니다.</li>\n</ul>\n<h3 id=\"삭제-flow\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C-flow\" aria-label=\"삭제 flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제 flow</h3>\n<ul>\n<li><code class=\"language-text\">탐색을 통해서 삭제하려는 노드</code>를 찾습니다.</li>\n<li>삭제하려는 노드의 왼쪽 노드를 삭제하려는 노드의 오른쪽을 가리키게 합니다.</li>\n<li>삭제하려는 노드의 <code class=\"language-text\">nextNode 를 null로</code> 만들어줍니다.</li>\n</ul>\n<h3 id=\"사용하면-좋을-상황\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84-%EC%83%81%ED%99%A9\" aria-label=\"사용하면 좋을 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용하면 좋을 상황</h3>\n<p>삽입과 삭제에서 배열보다 유리하기 때문에 삽입 삭제가 빈번히 발생하고 검색이 적을 때 사용하면 좋을 것 같습니다. 그 중에서도 삽입 삭제가 맨 앞에서 일어나는 상황이라면 더 LinkedList의 장점을 극대화해서 사용할 수 있겠습니다 ㅎㅎ</p>\n<h3 id=\"이중-linkedlist--node-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A4%91-linkedlist--node-%EA%B5%AC%EC%A1%B0\" aria-label=\"이중 linkedlist  node 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이중 LinkedList  Node 구조</h3>\n<ul>\n<li>prev Node  주소값과 data,  Next node 주소값을 가져요.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">E</span> item<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"특징-1\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-1\" aria-label=\"특징 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>위에서 언급한 단순 연결리스트와는 다르게 전, 후로 탐색이 가능한 구조입니다. 이전 노드주소와 이후 노드 주소를 한 노드에서 모두 알고 있습니다!</li>\n<li>가장 마지막 노드를 기억하고 있는 tail ! 만약 탐색하고 싶은 노드가 가장 뒤에서 부터라면 뒤에서 앞으로 탐색할 수 있어서 탐색 시간을 줄일 수 있어요.</li>\n</ul>\n<h2 id=\"느낀점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\"느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀점</h2>\n<p>자료구조 내부에 동작원리를 알게 되므로 코드를 작성할 때 타입 선택을 할때 메모리가 고정되어 있다면 배열을 사용하고, 동적이라면 ArrayList, 검색은 별로 안하지만 삽입 삭제가 많으면 LinkedList 를 사용해야겠다는 것을 알게 되었어요. 자료형을 선택할 때는 항상 이유있는 선택을 해야겠어요.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Arrays.html\">Arrays javadoc</a></li>\n<li><a href=\"https://hongcoding.tistory.com/74\">블로그 글</a></li>\n</ul>","frontmatter":{"date":"December 16, 2022","title":"Arrays vs LinkedList","categories":"java CS","author":"수달","emoji":"🙂"},"fields":{"slug":"/java3/"}},"prev":{"id":"2a4d7d6a-5c17-52c2-9663-c36bf28fc659","html":"<p>프로세스와 스레드를 학습하기에 앞서, 이해하고 있으면 좋은 개념인 CPU 와 RAM 에 대해서 간단히 알아보아요! ☺️</p>\n<h3 id=\"cpu란-core-processing-unit\" style=\"position:relative;\"><a href=\"#cpu%EB%9E%80-core-processing-unit\" aria-label=\"cpu란 core processing unit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU란? (core processing unit)</h3>\n<p>중앙 처리 장치로 컴퓨터를 통한 연산과 수행, 프로그램 실행을 담당하고 있어요\nCPU 는 출력을 전달하기 전에 RAM 에서 입력을 가져와 명령문을 이해하고 처리합니다.</p>\n<h3 id=\"ram란random-access-memory\" style=\"position:relative;\"><a href=\"#ram%EB%9E%80random-access-memory\" aria-label=\"ram란random access memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RAM란?(Random access memory)</h3>\n<p>프로그램이 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리 RAM 이란 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스할 수 있는 데이터 저장소입니다.</p>\n<ul>\n<li>데이터를 가져오기, 디코딩, 실행이 세가지가 cpu 의 핵심이자 전부에요!</li>\n</ul>\n<blockquote>\n<h2 id=\"프로세스process\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process\" aria-label=\"프로세스process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스(Process)</h2>\n</blockquote>\n<p>프로세스란 실행중인 프로그램을 뜻합니다. 즉, 파일 형태로 존재하던 프로그램이 메모리에 적재되어 CPU 에 의해 실행되는 것을 Process 라고 합니다.</p>\n<h3 id=\"메모리에-적재\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%81%EC%9E%AC\" aria-label=\"메모리에 적재 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리에 적재</h3>\n<p>메모리는 CPU가 직접 접근 할 수 있는 컴퓨터 내부의 기억 장치 입니다. Program이 CPU에서 실행되려면 해당 내용이 memory에 적재된 상태여야만 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACcklEQVQoz22SbU/aUBiGO7e5gEyNgEgLpS0tLRQKbXmzivg2dVl0L8IWjdmHKUyj/oFt3/bDr6XHaTTbhzvPyX1yrtzP8xzp8vKSbxfnnJ9fcHExYTr9zmQyFYrP02nsTYUmkwk3N7f8+PmLy6srRqMR4/FY1JOTE66vr5FktYxttTGsBqppk1cs5KKNojqsyBqZTJpMNksmkxHKZrPkZZlEIoEkSU+0vLyM5LgBnfYe7e4W7Z13+NvvqTUjat4atuNhaCUMXadcLj/INE0KRZlEcharUmZ+MUU2t4RlWUiVapNGa4OwvUOwfkDn7Rfc1kBAq0GE6daxGk10XUfTNCHDMJALK7yYnaHiWKTmkyxlF4Uv2TUf11uj1dzAC4cEnV381gZ+e5tGfwvLa2H74T/AvLLCy1fPBXjudYKlzCNgzVun09sjCAbU6l0qbgfH7WGaNUpFhZJaFKB7aPwwnU4/md/c3JwYhwDWWwM8f4DbXMWp9+7UWMVyvL8gQ8D+B3w2MyNqKpW6A8ZLqfubhNEO1dYqTiPCDYf4b46xG200VX0C03RdLCXe+OOEyWTyrmXDtNAUA/96QO/jBqvtNapuHU0voxtlSqXSE1mVCv0oEnV+YQGl2SeTV8iv5DDihKqqEgYBJ+enjE8/E/oBplnGMHSh+CtUq1UcxxEtxSlEYk3DbXgMb3+zczRiuL5GpWIjxZd7+/scf/jE6HhEt9cT88nlcqJapkm32yUMQ+HFnzf28/k8u7u7fD074+jwENu2KRQKSK7r0u/36fX7DDeHdDodZFmmWCyKGqe6ByqKIh7FftxZFEUcHBywtb390Mkfk9lnQ2C9l+sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1.png\"\n        title=\"1.png\"\n        src=\"/static/12774ef549f4c080492277c15148348f/37523/1.png\"\n        srcset=\"/static/12774ef549f4c080492277c15148348f/e9ff0/1.png 180w,\n/static/12774ef549f4c080492277c15148348f/f21e7/1.png 360w,\n/static/12774ef549f4c080492277c15148348f/37523/1.png 720w,\n/static/12774ef549f4c080492277c15148348f/f6f78/1.png 932w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프로세스에 할당되는  공간은 code, data, stack, heap 4개 의 영역으로 이루어져 있으며, 각 Process 마다 독립적으로 할당 받습니다.</p>\n<table>\n<thead>\n<tr>\n<th>code 영역</th>\n<th>실행한 프로그램의 코드가 저장됨</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data 영역</td>\n<td>전역 변수와 static 변수가 저장</td>\n</tr>\n<tr>\n<td>heap 영역</td>\n<td>프로그래머가 직접 할당, 해제 하는 공간</td>\n</tr>\n<tr>\n<td>stack 영역</td>\n<td>함수 호출시 생성되는 지역변수와 매개변수가 저장</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cpu의-연산과-pc-regisgter\" style=\"position:relative;\"><a href=\"#cpu%EC%9D%98-%EC%97%B0%EC%82%B0%EA%B3%BC-pc-regisgter\" aria-label=\"cpu의 연산과 pc regisgter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU의 연산과 PC regisgter</h2>\n<p>프로그램 코드를 토대로 CPU가 실제로 연산을 해야만 프로그램이 실행된다고 볼 수 있어요. 어떤 코드를 읽어야하는 것을 정하는 것은 CPU 내부에 있는 PC(program counter) register 에 저장되어 있습니다.  여기에는 다음에 실행될 코드의 주소값이 저장되어 있는데요.  즉 메모리에 code 영역의 명령중 다음번 연산에서 읽어야할 명령어의 주소값을 PC register가 순차적으로 가리키게 되고, 해당 명령어를 읽어와서 CPU 가 연산을 시작하면 프로세스가 되는 것 입니다!</p>\n<h2 id=\"멀티-프로세스-vs-멀티-스레드\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"멀티 프로세스 vs 멀티 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 vs 멀티 스레드</h2>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 말합니다. 동시에라는 말은 동시성과 병렬성 두가지를 의미합니다.</p>\n<p><code class=\"language-text\">동시성</code>은 CPU core 가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게되는 <code class=\"language-text\">시분할 시스템</code>으로 실행되는 것<code class=\"language-text\">병렬성</code>은 CPU core 가 여러개일 떄 <code class=\"language-text\">각각의 core 가 각각의 Process</code>를 연산함으로써 Process가 동시에 실행되는 것입니다.\n동시성은 실제로는 하나의 작업만 이뤄지는데 동시에 처리되는 것 같이 보이는 것을 의미하고, 병렬성은 실제로 여러 코어가 여러 작업을 실행하고 있는 것을 의미합니다.</p>\n<h3 id=\"멀티-프로세스\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"멀티 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스</h3>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 말합니다 이 때 <code class=\"language-text\">프로세스들은 CPU 와 메모리를 공유</code>하게 됩니다.\n메모리의 경우에는 여러 프로세스들이 각자의 메모리 영역을 차지하여 동시에 적재됩니다. 반면 하나의 CPU 는 매순간 하나의 프로세스만 연산할 수 있습니다. 하지만 CPU의 처리 속도가 워낙 빨라서 수ms 이내의 짧은 시간동안 여러 프로세스들이 CPU에서 번갈아가며 실행되기 때문에 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것 처럼 보입니다.</p>\n<p>이처럼 CPU의 작업 시간을 여러 프로세스들이 조금씩 나누어 쓰는 시스템을 <code class=\"language-text\">시분할 시스템</code>이라고 부릅니다.</p>\n<h3 id=\"메모리-관리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\" aria-label=\"메모리 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리</h3>\n<p>여러 프로세스가 동시에 메모리에 적재된 경우, 서로 다른 프로세스의 영역을 침범하지 않도록 각 Process가 자신의 메모리 영역에만 접근하도로 운영체제가 관리해줍니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACX0lEQVQoz12SWW/TQBSFncWJs3i3s9R24rGdTUUkrQAJ8TNIn+Gl6l4JKh4gSEHqpkr9B33pP/3QjEgXHo7OHc/1ucsc7eHhgdvbW+7u7ri6uuL6+lrx5eWlws3NjcLmu4z/rNdcfP/G6tdPflxc8Hu1Yr1e8/j4iBaGIY7rYlsmPZGTfvjE8N1HBov3BJ0uruvieR5BENDpdOj2+3iWiaZp+Lal2KiU8X2f8XiMlmUZs9mM+WJBVhTEyYAoSRhkOXlRMJlMmE6nikejEUUxQiQxrZrOm+kUp92iH/iMioLFzg5amqaMJxPezue4lomh6zimiV4uMRwkFKMRMmcD2UDU71Mvlwg9F6NaIXAdhBDM53M0GQyHQ0SaYrdbNBsGrm1Tq1ZIoi2VKIU2LAW7vS5aSVPjStiOre6U4KZynuc4joVR1zHbTYx6lTiOlMD/glHcp1orkxcZRqOO57/oMBXPgrZr02y38cOAWsMgTmIykb0aWYiMeLCF0aySFSkt0yDsei8FxT/BAst1abZb+IFPrdEgSgYIkb7eoZAdRuiGzlYSYbQM/NB/vcPNKG3Lpt5oYjkuFb1OMhyql5V3T3lC0I8TKnWDfDyh3mrhBOGzoBxV/iStYVnW06JLJY04jpVdXlpnPB4xEDmG5VBMZ5iuTyeKlRt2d3fRPNclimNm29vYtk2lUkHXdaq6rs7SsNLYkoMwpNfrYdqOKiqnUcWrOp7vq3fQVqsVBwcHHB0dcXp6yvn5OWdnZ4rl+eTkROH4+FjlyHh/f5+9vT2WyyXL5We+fvnC4eEh9/f3/AWrH2FEMhKjXAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2.png\"\n        title=\"2.png\"\n        src=\"/static/a553ff759ab4df92069dcdd96e974235/37523/2.png\"\n        srcset=\"/static/a553ff759ab4df92069dcdd96e974235/e9ff0/2.png 180w,\n/static/a553ff759ab4df92069dcdd96e974235/f21e7/2.png 360w,\n/static/a553ff759ab4df92069dcdd96e974235/37523/2.png 720w,\n/static/a553ff759ab4df92069dcdd96e974235/ecf19/2.png 948w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"cpu의-연산과-pc-레지스터\" style=\"position:relative;\"><a href=\"#cpu%EC%9D%98-%EC%97%B0%EC%82%B0%EA%B3%BC-pc-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0\" aria-label=\"cpu의 연산과 pc 레지스터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU의 연산과 PC 레지스터</h3>\n<p>CPU는 PC register가 가리키고 있는 명령어를 읽어들여 연산을 진행합니다. pc register 에는 다음에 실행될 명령어의 주소값이 저장되어 있어요. 멀티 프로세스 시스템에서는 <code class=\"language-text\">프로세스1 이 실행</code>되고 있을 때는 <code class=\"language-text\">프로세스1의 code 영역을 pc register</code>가 가리키다가, <code class=\"language-text\">process2가 진행되면</code> <code class=\"language-text\">prcess2의 code 영역을 가리키게 된다.</code> CPU는 PC register가 가리키는 곳에 따라 process를 변경해 가면서 명령어를 읽어들이고 연산하게 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB8UlEQVQoz1WSS08TURiGhxigTSuUlnYunTm3mc4Uyx0RwkKCmggY48aNSSudNvwHEoMrV/ov/Bf+JjcujNvHnMOlsHhzvvNdnrzn4l1eXjKdTinLcqbxzTqZTFzNysbj8ZhyMsHOjIbDe30ejbi4uHAznu/7WAVB8ECzvf8oHxBGEVIImisrBL5PGAT3sa17aZpyJyEUu/u7XH+7ZrA+QCnl8kYpjNZouzeGzc0NZByjRYKySmJSozFpiqe1QiuN1prUSPprPd69fUWWpQ6YKE2Ur5FkBdnGFpsHR5wdH+N5HvVajaWlJeY8DxF30cbMgNIoPn2s8uG94Wd5zna/RywlxhhMXmCyHjrr0R+sc7j3nOV6nWZjmVajQeNpHZkkzpSnboH2SE++e5yMNH+uSl6sF0RCuryS0rm1qzWQ5zlJEru7lCJxsa0/BhqN92OOl0PNv6uSg4dAfXMldsg6zoucbjfCzRpNN45mQH3bnGpNayfg7GjA369jDgYzoH4A7GUZ+9tbtFabtDst2u0Wq+0mUskboJQSK/uCQSA43R7w+8uQ/bWcMBEuL2+PLISgKArevD5xj1KtVqnVai6+c+mFYYhVFIY0/Q6HheHX+JRnSrDa8V3+rsf+Vwvd3dthYWGeSmWRSqXCwuI8Hb/jev4DwWMovVZHzqEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3.png\"\n        title=\"3.png\"\n        src=\"/static/4d49e96aeb29e57d38e6263d49693ca2/37523/3.png\"\n        srcset=\"/static/4d49e96aeb29e57d38e6263d49693ca2/e9ff0/3.png 180w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/f21e7/3.png 360w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/37523/3.png 720w,\n/static/4d49e96aeb29e57d38e6263d49693ca2/1b1d5/3.png 876w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"context\" style=\"position:relative;\"><a href=\"#context\" aria-label=\"context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context</h2>\n<p>시분할 시스템에서는 한 프로세스가 매우 짧은 시간동안 CPU 를 점유하여 일정 부분 명령을 수행하고, 다른 프로세스에게 넘기게 돼요. 그후 다시 차례가 되면 다시 CPU 를 점유하여 명령을 수행하죠 따라서 이전에 어디까지 명령을 수행했고, register에는 어떤 값이 저장되어 있었는지에 대한 정보가 필요하게 됩니다. process가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보가 바로 context 입니다!  context 정보들은 PCB(Process Control Block) 에 저장한답니다.</p>\n<h3 id=\"pcbprocess-control-block\" style=\"position:relative;\"><a href=\"#pcbprocess-control-block\" aria-label=\"pcbprocess control block permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB(Process Control Block)</h3>\n<p>PCB 운영체제가 프로세스를 표현한 자료구조입니다. 해당 공간에는 프로세스의 중요한 정보가 포함되어 있기 때문에 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 저장되어요. 일부 운영체제에서 PCB는 커널 스택에 위치합니다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABsElEQVQoz01SCXKEMAzj/y8sdApsgRxAIBCOsJc6Mt1tmfHYYEWWFZIj7tCqwrrM2LeAbQ1YV9YL4r4ixhVHPDPfj7jhOLYz/0bclzPHiCTuG+rqgskP8H5AmD1CmM6YPeZ5xDyN7x5x4+h+e156FEFh27Yhud1u6PsOdV0jyzK0rUXf97iUJbTWqKoKVfWNz88MeZ4jTT8kF0Uh+XIpMQwDns8n9n0/CbVWsNZiWRas6wqlGmRpijz/kgNNU0tNzDRNGMdRwnuqnOGce59NrtcriiIXFfSAH0MIAuZk1pzMdYilAOJIQHL2SUo8QxR2XQvnejnAYF1XlaxsrYE1RixpmgZlWYhqWkPlrMuiEPUkTu73u4CyLJVVScipVEeQ6/v3ewiz1Mtyqn4pm7wXxQxRaLQWlQTRXIKojt4opdB1Hdq2Rde2mCYvQ4bBwftRVBtjMDj3dynGaLlZevN4PGSyliGdDONfQDKSc0hrrQhgXzWNrE4OUUgSfiCAt83JXIuE9KeuTy+pRLyzp3daKfGWwT+AGLnl4zjEt/8PVXJ1Bj1+YVgz2H89xLwukyv/ALZMQwXhfUoiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4.png\"\n        title=\"4.png\"\n        src=\"/static/d00c1890f185efc4dcc33749f52e7c79/37523/4.png\"\n        srcset=\"/static/d00c1890f185efc4dcc33749f52e7c79/e9ff0/4.png 180w,\n/static/d00c1890f185efc4dcc33749f52e7c79/f21e7/4.png 360w,\n/static/d00c1890f185efc4dcc33749f52e7c79/37523/4.png 720w,\n/static/d00c1890f185efc4dcc33749f52e7c79/eb3fa/4.png 1026w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>PCB 에는 프로세스 상태와 PC(program counter(PC) 해당 process 가 다음에 실행할 명령어의 주소를 가리킵니다.</p>\n</blockquote>\n<h3 id=\"context-switch\" style=\"position:relative;\"><a href=\"#context-switch\" aria-label=\"context switch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Context switch</h3>\n<p>한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말해요.\n이때 이전의 프로세스의 상태를 PCB에 저장하여 보관하고, 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구하는 작업이 이뤄져요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABtElEQVQ4y5WSW2/aQBCF/ZwKcbGxvb6tsb1QCCG4LU5UErWVEhKBFLUPyW/xDXit8qdPNStt6xLUNA9HZ23PfHt2vNput8N+vwf5drtFVVX4+fyM3X6LIi+Q5wXKskJd1fK7qqvr+reXZYk8z1EUBTRd16FkGAZ6vR6+3a4wywTSpcD8s8CHqyFC4ULvUc2fetXTlBbHMZqKogir9RpJEiMWkdR4OkScRBgMBjisP5RGRaQwDKUI+O7kBLbNEAQBHMeFZdrwPR/tdhumacoaqlW9Tb0A0rrb7cpGOkK/35fHtCwLrVZLOiVpQppw7fAlued5sokScs6lU6pECDDmwncDeG6AwOfgPPwrkHZsJ3IFU/J9H5vvD1jefMSn5RTZ9RnmizFOz0fHEzahlEYlU0Ba3202SLMzpBcTLAiYTTB8n7w+Qxq+bdsyleu6cBxHum4YMPsWAo+/fuRDIMFolowx2LYlnzudDkzLfPtPYcyBZTJ5XUiUioCUmtL+97Uh5wHHan2P+WKCyUxgmo4wngoMolDOsrnxP4FKBPzx9Ijs+hwXX2a4uk1x+XUGMYpfjOYY8BdXdHyGT1OLowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5.png\"\n        title=\"5.png\"\n        src=\"/static/45ccf41f18b7818e5dbb389642094cdd/37523/5.png\"\n        srcset=\"/static/45ccf41f18b7818e5dbb389642094cdd/e9ff0/5.png 180w,\n/static/45ccf41f18b7818e5dbb389642094cdd/f21e7/5.png 360w,\n/static/45ccf41f18b7818e5dbb389642094cdd/37523/5.png 720w,\n/static/45ccf41f18b7818e5dbb389642094cdd/d7542/5.png 810w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-스레드란\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%9E%80\" aria-label=\"멀티 스레드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 스레드란?</h2>\n<p>스레드는 <code class=\"language-text\">한 프로세스 내에서 실행되는 동작(기능)의 단위</code>입니다.\n각 쓰레드는 속해있는 프로세스의 스택 메모리를 제외한 나머지 영역을 공유할 수 있습니다.</p>\n<p><code class=\"language-text\">멀티 쓰레드란 하나의 프로세스가 동시에 여러개의 일을 수행할 수 있도록 해주는 것</code>이다. 즉 하나의 프로세스에서 여러 작업을 병렬로 처리하기 위해서 멀티 쓰레드를 사용합니다.</p>\n<p>쓰레드는 프로세스 내에서 독립적인 기능을 수행합니다. 즉, 독립적으로 함수를 호출함을 의미하고, 이를 위해 스택 메모리가 각자 필요합니다. 쓰레드가 무엇인지 이해하고, 멀티 프로세스와 어떤 점이 다른지를 생각해보면서 공부하면 좋을 듯 합니다.</p>\n<h3 id=\"stack-memory--pc-register\" style=\"position:relative;\"><a href=\"#stack-memory--pc-register\" aria-label=\"stack memory  pc register permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack memory &#x26; PC register</h3>\n<p>스레드가 함수를 호출하기 위해서는 인자 전달, return Address 저장, 함수 내 지역변수 저장 등을 위한 독립적인 stack memory 공간을 필요로 합니다. 결과적으로 스레드는 프로세스로부터 스택 메모리 영역은 독립적으로 할당받고, 나머지 영역은 공유하게 되어요</p>\n<p>또한 멀티 스레드에서는 각각 스레드마다 PC 레지스터를 가지고 있어야해요. 그 이유는 한 프로세스 내에서도 쓰레드끼리 context swich가 일어나게 되는데 PC 레지스터에 code address가 저장되어 있어야 이어서 실행을 할 수 있기 때문이에요.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADRUlEQVQ4y4WUz29UVRTHJ9EYZWNIjBtjjMiOhUtj9B9wYaNhgwYK9UdAlAW2SVEqIlEgtcKiZKxTNEgCo4mBgaYgQqGdQmmTdlqmi47Tmc77/ea9aWcYp3ba+fUx99I3VCbam5z37nv33m8+59xzjq9UKrG4uMjS0hKFQoHFQoFMbolZNUvoSpjBkSiK9Re5/N+USiuI/SsrKywvL8u3910ul6nVavjEj/n5eWzbRtN01FSczrP3aGq9yc4jo2z/8g5Nbbc43x9FUxIYhkk8HicWi5FMJlFVlUQiIc+L4RMPx3Hkgm2nWchYHOmNsLV9iG2fh3nnYJg3W4c4E5pCVxMYpiXFZmZmSKVS6LouhYWgJBSPtSNtafzUF2Pn17fZ8+1dae8dG+H3OwkyjoXrZnBdVwqYpilhxDuXy1GpVB4Qinjk83nu5/M4ls7ZW0n29kboCE7z2bkoewLjDEQt1hsifFIwnU6jKAppx8W1DQLXk7T03OPgrzHagzM0+ye5MmHKQ5VqVbq21qrV6oM1Qdjoss6PfZM0f9PPxyeus/fEH3J+bTQh16vVWgOZp9EQQ7E5O+/wfqsf37Nbeeql7WzYvEPOTwb6Vimq/ylYj6EI8NzcHIqiks9leHdfN09s2sGLr+7jhVc+4cnNzXR+f1keKv+PoHBdEhaLRZnYxeIy2QWHXfv9+J7fxjMvf8TTWz7Et/EtjnZfXBWsrC9Yd7kGuazL2x904Xv8DXwbXuOx55rY9PqnBEO36249eikNgmvNtkwuXxtj94HTtOxuY2DghsexbtrUb/mhga6rTMUXGIhk6fRfoPeXMP13XcanFTRVwXFcmWKiSgzDkJUiElvQSUIvh7xhWxo/98VoPzXBIf8Ih3vGOHBqgvCEIZyiVC7LBH7UPKj6pchKuZ/HNDSGIyYXhiwOdQXpClwlNJxmfFqVa24mg6ZpsvYFmWdebOtpIzZYto2bNjl3Nc4XP0zR0T3IVz0jdPRMMhx5SCgARLmKllVeJfYqpqFSdHWO324k6Tofp6Wtl/1HQ3wXnOXm6Cy2qcvmIAiFWZbVSCiaq9c1RIANTeHSYIrjZ6Y4fSlO4OKfcj4WNalWRGP9d5P1zIvhPxwp+5mn/pwiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6.png\"\n        title=\"6.png\"\n        src=\"/static/12c28b038387e80d2030a27ab8967e6d/37523/6.png\"\n        srcset=\"/static/12c28b038387e80d2030a27ab8967e6d/e9ff0/6.png 180w,\n/static/12c28b038387e80d2030a27ab8967e6d/f21e7/6.png 360w,\n/static/12c28b038387e80d2030a27ab8967e6d/37523/6.png 720w,\n/static/12c28b038387e80d2030a27ab8967e6d/0a867/6.png 986w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-프로세스-vs-멀티-스레드-1\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-1\" aria-label=\"멀티 프로세스 vs 멀티 스레드 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 vs 멀티 스레드</h2>\n<ul>\n<li>멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 컨텍스트 스위칭이 빠르다.</li>\n<li>멀티 프로세스는 멀티 스레드보다 많은 메모리 공간과 cpu 시간을 차지한다.</li>\n<li>멀티 스레드 환경에서는 <code class=\"language-text\">동기화 문제</code>나 하나의 쓰레드가 장애가 날 경우 전체 스레드가 종료될 위험이 있다.</li>\n<li>멀티 프로세스의 경우에는 하나의 프로세스가 죽어도 다른 프로세스의 영향을 주지 않아 안정성이 높다.</li>\n</ul>\n<h2 id=\"언제-무엇을-사용해야하는가\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"언제 무엇을 사용해야하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용해야하는가?</h2>\n<p>메모리 구분이 필요할 때는 멀티 프로세스가 유리합니다. 반면에 컨텍스 스위칭이 자주 일어나고, 데이터 공유가 빈번한 경우, 그리고 자원을 효율적으로 사용해야하는 경우에 멀티 스레드를 사용하는 것이 유리해요</p>\n<h2 id=\"멀티-프로세스-환경에서-프로세스간에-데이터를-어떻게-주고-받는-법\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EB%B2%95\" aria-label=\"멀티 프로세스 환경에서 프로세스간에 데이터를 어떻게 주고 받는 법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스 환경에서 프로세스간에 데이터를 어떻게 주고 받는 법</h2>\n<p>원칙적으로는 독립적인 주소 공간을 가지고 있기 때문에 다른 프로세스의 주소 공간을 참조할 수 없다. 하지만 경우에 따라 운영체제는 프로세스 간의 자원 접근을 위한 매커니즘인 프로세스 간 통신(IPC, Inter Process Communication) 을 제공합니다.</p>\n<h3 id=\"ipc\" style=\"position:relative;\"><a href=\"#ipc\" aria-label=\"ipc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IPC</h3>\n<p>기본적으로 공유 메모리와 메시지 전달 두가지 모델이 있습니다.</p>\n<h3 id=\"공유-메모리\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"공유 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공유 메모리</h3>\n<p>공유 메모리 방식에서는 <code class=\"language-text\">프로세스들이 주소 공간의 일부를 공유</code>해요.  공유한 메모리 영역에 읽기 쓰기를 통해서 통신을 수행합니다.\n프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해주어요. 공유 메모리 영역이 구축된 이후에는  모든 접근이 일반적인 메모리 접근으로 취급되기 때문에 더이상 커널의 도움 없이도 각 프로세스들이 해당 메모리 영역에 접근 할 수 있어요. 하지만 일관성 문제가 발생할 수도 있습니다. 이에 대해서는 커널이 관여하지 않기 때문에 프로세스들 끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+klEQVQoz2WSbVMaMRSFs2/AygJaoXZxN5uXXUClo7RUKm21tePg1Bn//795OonIYPvhzM2H5Mm95x6xvL7mz/Mzvx4euFwsKMsSrbWXlCVpkhAJQRQIOkmMLAu0Niil/B1X98/i03LJ1/Wa1c0Nl1dXby9ISRKF9Pt9sl6POAz+A+30CvyyWvHt9paVg67XaGPeAF1XvSwj6x7QCgPs7Aw7maKqCq3Vbhq9BYuiKCjGY4px7qtxsC3Qjd+KYwIhCIUgcR02U5rzCw9UxiCVQm7PHmitYTjoMzwc8PFsRieOKPMcay3uMxEECCF2qhzwYk6lFO1uRl6U6LohbqeUSiOs0Rz3uxxmB0yMohMHyPyDB7oO4yQiDAPCKCSKQsz5HDuZeM9aWY9hnnOqFFG6BRoHPOphjeTqcs7weMB4/J66rinKgsN3fbRVVKrkaHRMvVhijEWqimyQ0UwbZuczfy5kgXBeVcWYIj9h1ljykxFalhj94k+72yVut71aaUplLNPFZ4zzzxh0XTObz8nL0vsopJT8uPvJ5unJ6/dmQ9NMvMEOGMYJo9GI0XBIEMW+w9pt2hoeHh+5u7/39fvtHXXTvHToH0tJ5ba1l0O3vVZ64EFOSSelsvUuIs5j9+6llv692OXonzy9xibc27KLT3F66sd9vbMvF5u/iKwlgSYqcuAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"7.png\"\n        title=\"7.png\"\n        src=\"/static/95dd8457ce7bbd731ad495f84798d0b5/37523/7.png\"\n        srcset=\"/static/95dd8457ce7bbd731ad495f84798d0b5/e9ff0/7.png 180w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/f21e7/7.png 360w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/37523/7.png 720w,\n/static/95dd8457ce7bbd731ad495f84798d0b5/d30ee/7.png 980w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"메시지-전달\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC\" aria-label=\"메시지 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 전달</h2>\n<p>통상 system call 을 사용하여 구현 되어요. 커널을 통해 샌드와 리시버 라는 두가지 연산을 제공 받는다. 예를 들면, 프로세스1이 커널로 메세지를 보내면 커널이 프로세스 2에게 메세지를 보내주는 방식으로 동작합니다. 메모리 공유 보다는 속도가 느리지만, 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용하다. 또 구현하기 쉽다는 장점이 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABaklEQVQoz6WSe2vCMBTFo87W9MUEBZ21ebRat9WW6TaYD9aJw0Fhj+//Yc5ItMNuDBz74+Qm3Jsf54SQJE2xXK+xKwo8bbcIggCcczDOEQoBetYENU2cux6eX16Q7woMuYAQApwxPVuKMQZyM5+jeHvFOs+xWK0gpdRNdUHJphQ1QtAgNRBC4IcjXM7vMUrS/czRrLpHoijCdZIgnkx0LYFKoRRwLYpmo4GW0YRjWxCMYZzNIMexhiqXFaBaVExllx3ils1ISrQMA67nwfM8FB/veNxs4A8DRPEEo2kGzoIqsDwcq3QopYDn2KiryPV95ItuB+E4Rjy7hfj2PL8DD00ZhrBcFy1KQamFqzRD+rBENM10j3P2BToRGMGklo7cbrexyHPc5Rv4gwGE4JU0J0VWe2o7Oiqp13XtdjoItbsq6GSgaRgapL6Oqv1+v/K1/uzQOABL9Xq9/wHV2zmOA9d1dfV9/0fMY+An4wsprBnVZbQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"8.png\"\n        title=\"8.png\"\n        src=\"/static/e64db8d1e895868abd91f33690602dd8/37523/8.png\"\n        srcset=\"/static/e64db8d1e895868abd91f33690602dd8/e9ff0/8.png 180w,\n/static/e64db8d1e895868abd91f33690602dd8/f21e7/8.png 360w,\n/static/e64db8d1e895868abd91f33690602dd8/37523/8.png 720w,\n/static/e64db8d1e895868abd91f33690602dd8/91f10/8.png 992w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"멀티-프로세스-스레드-환경에서-동기화-문제를-어떻게-해결하나요\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"멀티 프로세스 스레드 환경에서 동기화 문제를 어떻게 해결하나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스/ 스레드 환경에서 동기화 문제를 어떻게 해결하나요?</h2>\n<p>동기화문제를 해결하기 위해 뮤텍스와 세마포어 기법을 사용할 수 있어요. 뮤텍스란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법입니다. 공유 자원을 점유하는 스레드가 락을 걸게 됩니다. acquire 함수를 사용하여 Lock 을 획득하고 release 함수가 Lock 를 반환해요.</p>\n<p>이때 락이 안풀리는데 계속 접근하고 취소하는 등 하는 부분을 busy waiting 이라고 하는데 다른 프로세스/스레드가 생산적으로 사용할 수 있는 CPU 를 낭비한다는 단점이 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACfElEQVQoz1WTy08TURTGp2DBmgCJ0xba6WOe996ZtjPThxofxTexiFi3rtmz8BVNXCoIvjEiUSNu1H9B92z5l35mpkJkcXLuPcn9zjnf913NsiziTod2t4tpmiT3JJJz3axjGAaGUcY062ntoF4qlchkMmiadhiVSgWt1WpxYzAgbrep1+spWPIgycKRXL5wlYXLA6KgQ6hiWjKkoRpIJRkbHz8CmDTXVlZW+PXzB/35c8yV5rBtCyV8Wn6McBTv322xu7uL7/vYrkSqkF6vz+1bd9GnZyhMzzCn60yOZTBrVbThnTtsrr/Ac1zOnr5AJ+7gywZSSvS8ztrac7Y/7VCzFTKIsD2FqwIuXV+kG52hohsYVkguN0XFKKENbw/Z+fgZ1xJc6V+j1+3hCQ9PCHRdZ3Nzg89fv5EvFPFcF9/zCVVE1IoxLZfsRJaZos14dpJyuYw2HA7Z3trBEy7n++dpNpspWBLFQpHXm2/4/uU7TtWlqSKUFyA8wezsLNnsOHXbY6ZooWWOpeKlgB+3tvFswbX5BcIwwnUEnbBHtVzn1cZb1p89x7RqxHEbP/BxHAfTspnMTTNbcXH8mOO53GjCpaUl/vz5TTvq0G51UcrH9wM8zyOvn2R94xX3HjzCdALO9BdotmL8ZgdXNpk4PkWhbDFnVJmYnBipPBgM2NvbI2gEGBXj0IO27VAo5Fl78ZL7Dx+jpGB+vk8UhkilsBzBiak82tixoz5cXl5mf38/5a5Wqx0aO1krn9d58+4Dj588RaoG/YtXEGKktiuCQ2Mf5BSw2+2yuro64uXfTxlNaKecLC7eJNlCBjGnzl5KKRFSUqtVyfxn6gPAv4UbVfX3Dye/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9.png\"\n        title=\"9.png\"\n        src=\"/static/e8ec8624b1b24871d474abe756f3f5cd/37523/9.png\"\n        srcset=\"/static/e8ec8624b1b24871d474abe756f3f5cd/e9ff0/9.png 180w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/f21e7/9.png 360w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/37523/9.png 720w,\n/static/e8ec8624b1b24871d474abe756f3f5cd/1568e/9.png 892w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>세마포어는 S개의 스레드만이 공유 자원에 접근할 수 있도록 제어하는 동기화 기법입니다. 세마포어 기법에서는 정수형 변수 값을 가용한 자원의 수로 초기화하고, 자원에 접근할 때는 S— 연산을 수행하여 세모포 값을 감소시키고 자원을 방출할 때는 S++ 연산을 수행하여 세바포 값을 증가 시킴. 이때 값이 0이 되면 모든 자원이 사용중이다.라고 인식하고, 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 Block 됩니다.</p>\n<p>바이너리 세마포어라고 값이 0, 1만 가질 수 있는 경우, 바이너리 세마포어라고 하는데 이는 뮤텍스랑 거의 유사하게 작동한다고 보면 됩니다.</p>\n<h2 id=\"교착-상태deadlock-란\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9Cdeadlock-%EB%9E%80\" aria-label=\"교착 상태deadlock 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착 상태(Deadlock) 란?</h2>\n<p>둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말해요.\n데드락이 발생하는 조건은 상호 배제, 점유 대기, 비선점, 순환대기 이 네가지 조건이 동시에 성립할 때 발생할 수 있어요.</p>\n<ol>\n<li>상호 배제\n<ul>\n<li>동시에 한 스레드만 자원을 점유할 수 있는 상황</li>\n<li>다른 스레드가 자원을 사용하려면 자원이 방출될 때까지 기다려야한다.</li>\n</ul>\n</li>\n<li>점유 대기\n<ul>\n<li>스레드가 자원을 보유한 상태에서 다른 스레드가 보유한 자원을 추가로 기다리는 상황</li>\n</ul>\n</li>\n<li>비선점\n<ul>\n<li>다른 스레드가 사용중인 자원을 강제로 선점할 수 없는 상황이다.</li>\n<li>자원을 점유하고 있는 스레드에 의해서만 자원이 방출된다.</li>\n</ul>\n</li>\n<li>순환대기\n<ul>\n<li>대기 중인 스레드들이 순환형태로 자원을 대기하고 있는 상황이다.</li>\n</ul>\n</li>\n</ol>\n<p>해결 방법은 무시, 예방, 회피, 탐지-회복의 4가지 방법이 있다.</p>\n<ol>\n<li>무시\n<ul>\n<li>데드락이 발생할 확률이 낮으면 무시하는 것이다.</li>\n</ul>\n</li>\n<li>예방\n<ul>\n<li>교착상태 4가지 발생 조건 중 하나가 성립하지 않게 막는 방법이다.</li>\n<li>자원 사용의 효율성이 떨어지고, 비용이 크다.</li>\n</ul>\n</li>\n<li>회피\n<ul>\n<li>스레드가 앞으로 자원을 어떻게 요청할지에 대한 정보를 통해 순환 대기 상태가 발생하지 안호록 자원을 할당하는 방법이다.</li>\n<li>은행원 알고리즘이 쓰임</li>\n</ul>\n</li>\n<li>탐지 - 회복\n<ul>\n<li>시스템 검사를 통해 데드락 발생을 탐지하고, 이를 회복 시키는 방법이다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href=\"https://learn-news.info/2\">CPU</a></li>\n<li><a href=\"https://www.dell.com/support/kbdoc/ko-kr/000148441/%EB%A9%94%EB%AA%A8%EB%A6%AC-ram-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C\">RAM</a></li>\n</ul>\n<h2 id=\"대답해보면-좋을-항목\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EB%8B%B5%ED%95%B4%EB%B3%B4%EB%A9%B4-%EC%A2%8B%EC%9D%84-%ED%95%AD%EB%AA%A9\" aria-label=\"대답해보면 좋을 항목 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대답해보면 좋을 항목</h2>\n<ul>\n<li>프로세스를 간단히 설명해주세요</li>\n<li>프로세스의 메모리영역(code, data, stack, heap) 에 대해서 설명해주세요</li>\n<li>멀티 프로세스에 대해서 설명해주세요</li>\n<li>프로세스의 컨텍스트는 무엇인가요?</li>\n<li>Process Control Block 에 저장되는 것들은 무엇이 있나요?</li>\n<li>프로세스의 상태에는 어떤 것들이 있나요?</li>\n<li>멀티 쓰레드가 멀티 프로세스보다 좋은점은 무엇인가?</li>\n<li>멀티 프로세스가 멀티 스레드보다 안좋은 점은 무엇인가?</li>\n</ul>","frontmatter":{"date":"December 21, 2022","title":"프로세스와 스레드","categories":"cs","author":"수달","emoji":"🙂"},"fields":{"slug":"/os/"}},"site":{"siteMetadata":{"siteUrl":"https://her0807.com","comments":{"utterances":{"repo":"https://github.com/her0807/her0807.github.io"}}}}},"pageContext":{"slug":"/java6/","nextSlug":"/java3/","prevSlug":"/os/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}