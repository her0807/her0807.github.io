{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/spring","result":{"pageContext":{"currentCategory":"spring","categories":["All","etc","spring","독서","java","보안","architecture","cs","개발독서","db"],"edges":[{"node":{"id":"00cc2abd-74a9-5046-ba95-58123e3c41d1","excerpt":"왜 NamedLock 을 사용해야하는가 ? 보통 분산락이라는 키워드로 검색을 해보면 레디스가 많이 나오는데요, MySQL lock 을 사용해서도 분산락을 구현할 수 있어요! 레디스를 사용하려면 인프라 구축 비용도 들고, 비지니스 로직 또한 별도로 구축해주어야하기 때문에 바용이 꽤 크다고 볼 수 있어요. 만약 지금 MySQL 을 사용하고 있다면, 이름으로 Lock 을 지정해줄 수 있는 네임드 락을 이용해서 분산락을 구현하면 어플리케이션 단에서 제어가 가능하고, 인프라 구축 및 유지보수 비용도 줄일 수 있습니다! NamedLock 사용 방법 직접 MySQL 키워드를 사용하여 LOCK 을 획득하면 됩니다.  저희는 네이티브 쿼리를 사용해서 획득하고 싶은 락에 대한 이름을 매개변수로 넘겨주어 락을 구현해보겠습니다. STEP 1) 락 획득하기 GET_LOCK(str,timeout) 입력받은 이름(str) 으로 timeout 초 동안 잠금 획득을 시도합니다. timeout 에 음수를 입력하면…","fields":{"slug":"/concurrency/"},"frontmatter":{"categories":"spring","title":"NamedLock - [재고 시스템으로 알아보는 동시성 이슈]","date":"January 01, 2023"}},"next":{"fields":{"slug":"/etc4/"}},"previous":{"fields":{"slug":"/etc2/"}}},{"node":{"id":"e0e22c13-f46e-5733-8ed8-bbb0a7bd78f7","excerpt":"학습 동기 스프링을 사용하면서 습관처럼 의존성 주입을 생성자 주입으로 받곤 했어요. 처음 접한 방식은 @Autowired 였는데 매 필드마다 달아주는게 너무 힘들었거든요. 생성자는 IDE 에서 자동 생성이 되니까 편리하게 사용이 가능하고, 필드에 final 을 붙일 수 있어 불변을 보장해줘서 더 안정적이게 느껴졌어요. 그러다 문득 의존성을 주입하는 방식이 3가지나 있는데, 지금 방법보다 더 나은 방법은 없을까? 궁금해졌어요. 그래서 장단점을 파악해보기로 했습니다. 의존성 주입이란 무엇일까요? ☺️\n의존성 주입이란 스프링에서 제공하는 DI 기능입니다. 스프링에서는 객체를 싱글톤 빈으로 관리하고, 필요한 곳에 적절히 주입시켜주어 객체를 계속 생성해 부하가 발생하는 문제를 해결했어요!  그래서 대용량 트래픽 처리에 스프링을 사용하면 좋을 것 같다는 생각을 했습니다. 생성자 주입(Constructor Injection) 생성시 값이 주입되기 때문에 final 키워드를 붙여 불변을 보장할 수…","fields":{"slug":"/spring2/"},"frontmatter":{"categories":"spring","title":"Spring 을 사용하여 의존성을 주입할 시 생성자를 사용해야하는 이유","date":"December 22, 2022"}},"next":{"fields":{"slug":"/design_pattern/"}},"previous":{"fields":{"slug":"/spring/"}}},{"node":{"id":"2f57a9af-ee92-59d1-8284-1d698dc35db7","excerpt":"학습동기 prolog project test code 를 작성하다가 생성자 주입과 autowired 로 의존성 주입을 하는 방식 모두를 사용하고 있는 코드를 발견했어요. 왜 junit 을 사용하는 test 에서 두개의 의존성 주입 방식을 사용하게 된걸까요?  이전부터 궁금했던건데 테스트 코드에서는 의존성 주입 방식을 무조건 autowired 로 해야하는지도 의문이 들었어요. 문제 코드 결론부터 말씀드리자면 TestClass 에서는 하나의 의존성 주입 방식을 사용하고 있어요. 테스트 코드를 작성하기 위해 사용하는 라이브 러리인 Junit 에서는 스프링과 별개로 의존성 주입을 하고 있어요.그래서 위 코드에서 생성자를 만든건 생성자로 의존성을 주입하기 위해서가 아니었더라구요. 각각 @autowired 를 달아주는 번거로움을 해소하고자   어노테이션으로 생성자 위에 autowired 를 달아준 것과 같은 효과를 내기 위해서 였어요. @autowired 로 의존성을 주입하지 않으면   이 …","fields":{"slug":"/spring3/"},"frontmatter":{"categories":"spring","title":"SpringBootTest 에서 의존성 주입 방식이 @autowired 로 강제되는 이유","date":"December 12, 2022"}},"next":{"fields":{"slug":"/undo/"}},"previous":{"fields":{"slug":"/etc/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}