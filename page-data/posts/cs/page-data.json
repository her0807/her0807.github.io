{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/cs","result":{"pageContext":{"currentCategory":"cs","categories":["All","etc","spring","독서","java","보안","architecture","cs","개발독서","db"],"edges":[{"node":{"id":"2a4d7d6a-5c17-52c2-9663-c36bf28fc659","excerpt":"프로세스와 스레드를 학습하기에 앞서, 이해하고 있으면 좋은 개념인 CPU 와 RAM 에 대해서 간단히 알아보아요! ☺️ CPU란? (core processing unit) 중앙 처리 장치로 컴퓨터를 통한 연산과 수행, 프로그램 실행을 담당하고 있어요\nCPU 는 출력을 전달하기 전에 RAM 에서 입력을 가져와 명령문을 이해하고 처리합니다. RAM란?(Random access memory) 프로그램이 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리 RAM 이란 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스할 수 있는 데이터 저장소입니다. 데이터를 가져오기, 디코딩, 실행이 세가지가 cpu 의 핵심이자 전부에요! 프로세스(Process) 프로세스란 실행중인 프로그램을 뜻합니다. 즉, 파일 형태로 존재하던 프로그램이 메모리에 적재되어 CPU 에 의해 실행되는 것을 Process 라고 합니다. 메모리에 적재 메모리는 CPU가 직접 접근 할 수 있는 컴퓨터 내부의 기억 장치 입니다. …","fields":{"slug":"/os/"},"frontmatter":{"categories":"cs","title":"프로세스와 스레드","date":"December 21, 2022"}},"next":{"fields":{"slug":"/java6/"}},"previous":{"fields":{"slug":"/design_pattern/"}}},{"node":{"id":"4e3535f2-4b48-5790-bde3-4f86100f2dec","excerpt":"학습 동기 정렬 알고리즘에 대해서 공부하다가 Arrays.sort 내부 구현체는 Comparable 을 상속받아 구현되어 있다는 내용을 알게 되었습니다.  Comparable 의 특징과 동작원리를 알게되면 더욱 효과적으로 사용할 수 있을 것 같아서 읽게 되었어요. Comparable 자바에서 제공되는 정렬이 가능한 클래스들은 모두 Comparable 인터페이스를 구현하고 있으며, 정렬 시에 이에 맞게 정렬이 수행됩니다. Integer 와 Double 클래스는 숫자 오름차순으로 정렬되어 있어요. String은  A-Z, 1-9 같이 사전순으로 정렬되어 있어요. 유일무이한 메서드 compareTo 해당 인터페이스에는 메서드가 compareTo 딱 하나뿐이에요. 이 compareTo 를 재정의해서 정렬 조건을 사용할 의도에 맞춰서 변경할 수 있어요! 비교 값이 0 이면 같다. 비교 값이 1 (양수) 이면 크다. 비교 값이 -1 (음수) 이면 작다.  정렬이고, 비교군을 반대로 한다면 내…","fields":{"slug":"/java6/"},"frontmatter":{"categories":"cs 개발독서","title":"[Effective Java -14장] Comparable 을 구현할지 고려해라","date":"December 16, 2022"}},"next":{"fields":{"slug":"/java3/"}},"previous":{"fields":{"slug":"/os/"}}},{"node":{"id":"ef2f5533-0bce-52dd-86ee-87a658d3517f","excerpt":"학습 동기 평소에 목록을 저장하기 위해서 배열이나 List 자료 형을 썼었는데, 배열과 ArrayList 는 메모리 크기가 고정되어 있는지, 동적으로 커지는지에 차이가 있다고 생각되어 구분하여 잘 사용 했었습니다. 그런데 알고리즘을 풀면서 LinkedList 와는 잘 비교해서 사용하지 않았던 것 같아서 정리해보고자 합니다. 배열(Arrays) 배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 자료구조에요 Index 를 통해서 접근이 가능하고 0 번부터 시작합니다. 최초 크기가 고정되면 바꿀 수 없어요. 시간 복잡도 조회는 접근하고자 하는 인덱스만 안다면 O(1) 시간이 걸려요. 순차 탐색시는 최대 O(n) 이 소모됩니다. 삽입 및 삭제 배열의  삽입, 삭제 O(n) 삭제된 원소 뒤에 있는 원소들을 한칸씩 옮겨야 해서 O(n) 이 소모됩니다. 배열의 에 삽입 및 삽입, 삭제  O(1) 가장 뒤에는 옮길 원소가 없기 때문에 O(1) 이 소모됩니다. 사용하면 좋은 상황 …","fields":{"slug":"/java3/"},"frontmatter":{"categories":"java cs","title":"Arrays vs LinkedList","date":"December 16, 2022"}},"next":{"fields":{"slug":"/java2/"}},"previous":{"fields":{"slug":"/java6/"}}},{"node":{"id":"afc87c75-0c33-5016-94c3-1486fd3579e0","excerpt":"학습 동기 알고리즘 문제를 풀면서 배열과 ArrayList 의 가장 큰 차이는 메모리가 고정되어 있는지, 동적으로 늘어나는지에 따라 상황에 맞게 사용했었습니다. 그런데 문득 ArrayList 도 내부는 배열로 되어 있는데 어떤 방식으로 사이즈가 동적으로 늘어날까 궁금해졌습니다. ArrayList 내부 구조 최초에는 빈 배열로 생성되었다가 add 가 한번이라도 생성 되는 시점에 빈 배열이라면 기본 값인 10으로 사이즈 설정을 해줍니다. 그리고 원소의 개수가 10을 넘었을 때, 해당 배열의 사이즈의 절반만큼 크기를 늘려주고 있습니다. 중간 삽입(add(index, data) 이나 삭제 할 때 (remove) 동작 원리 Index 없이 삽입할 때는 배열의 바로 뒤에 삽입하기 때문에 원소를 뒤로 밀 필요가 없는데, 만약에 삽입시 index 를 지정해서 삽입하는 경우나 첫번째부터 맨 뒤 바로 앞 원소를 삭제하는 경우는 배열을 밀거나 당겨줘야한다. 내부 구현체에서는   를 사용하여 해당 인덱…","fields":{"slug":"/java2/"},"frontmatter":{"categories":"cs","title":"ArrayList 가 동적으로 사이즈가 늘어나는 동작 원리!","date":"December 16, 2022"}},"next":{"fields":{"slug":"/java7/"}},"previous":{"fields":{"slug":"/java3/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}