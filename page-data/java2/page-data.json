{"componentChunkName":"component---src-templates-blog-template-js","path":"/java2/","result":{"data":{"cur":{"id":"afc87c75-0c33-5016-94c3-1486fd3579e0","html":"<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>알고리즘 문제를 풀면서 배열과 ArrayList 의 가장 큰 차이는 메모리가 고정되어 있는지, 동적으로 늘어나는지에 따라 상황에 맞게 사용했었습니다. 그런데 문득 ArrayList 도 내부는 배열로 되어 있는데 어떤 방식으로 사이즈가 동적으로 늘어날까 궁금해졌습니다.</p>\n<h2 id=\"arraylist-내부-구조\" style=\"position:relative;\"><a href=\"#arraylist-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0\" aria-label=\"arraylist 내부 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList 내부 구조</h2>\n<p>최초에는 빈 배열로 생성되었다가 add 가 한번이라도 생성 되는 시점에 빈 배열이라면 기본 값인 10으로 사이즈 설정을 해줍니다.</p>\n<p>그리고 원소의 개수가 10을 넘었을 때, 해당 배열의 사이즈의 절반만큼 크기를 늘려주고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">DEFAULT_CAPACITY</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>elementData <span class=\"token operator\">=</span> <span class=\"token constant\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">newCapacity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// overflow-conscious code</span>\n       <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> minCapacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>elementData <span class=\"token operator\">==</span> <span class=\"token constant\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token constant\">DEFAULT_CAPACITY</span><span class=\"token punctuation\">,</span> minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// overflow</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OutOfMemoryError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> minCapacity<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"중간-삽입addindex-data-이나-삭제-할-때-remove-동작-원리\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EA%B0%84-%EC%82%BD%EC%9E%85addindex-data-%EC%9D%B4%EB%82%98-%EC%82%AD%EC%A0%9C-%ED%95%A0-%EB%95%8C-remove-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-label=\"중간 삽입addindex data 이나 삭제 할 때 remove 동작 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중간 삽입(add(index, data) 이나 삭제 할 때 (remove) 동작 원리</h3>\n<p>Index 없이 삽입할 때는 배열의 바로 뒤에 삽입하기 때문에 원소를 뒤로 밀 필요가 없는데, 만약에 삽입시 index 를 지정해서 삽입하는 경우나 첫번째부터 맨 뒤 바로 앞 원소를 삭제하는 경우는 배열을 밀거나 당겨줘야한다. 내부 구현체에서는  <code class=\"language-text\">System.arraycopy</code> 를 사용하여 해당 인덱스 위치만큼 앞 뒤로 복사하여 새로운 배열을 만드는 방식으로 구현하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fastRemove</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> es<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> newSize<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>newSize <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> i<span class=\"token punctuation\">)</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>es<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> es<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> newSize <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        es<span class=\"token punctuation\">[</span>size <span class=\"token operator\">=</span> newSize<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p><strong>실제로는 가지고 있던 메모리 크기가 꽉 찼을 때, grow() 메서드를 사용하여  기존 사이즈의 1.5배를 늘린 새로운 배열에 기존 배열을 copy하는 것이었습니다!</strong></p>\n<h2 id=\"느낀점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\"느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀점</h2>\n<p>만약 ArrayList 를 사용할 때 예상되는 최대값이 10이상이라면 처음 크기를 지정할 수 있으니, 초기값으로 큰 사이즈를 넣어주면 grow() 하는 과정을 조금이나마 줄일 수 있으니 효율적일 것 같다고 생각이 되었습니다. 또한 자체적으로 System 내에서 구현한 arraycopy 를 재활용한 로직이 굉장히 감탄스러웠습니다. 이번 내용을 학습하면서 다시금 자바의 객체 지향적임, 단일책임에 대한 고민들이 느껴져서 자바의 매력에 푹 빠지게 되는 것 같네요 👍🏻</p>\n<h2 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html\">ArrayList javadoc</a></li>\n<li>구현체 살펴봄!</li>\n<li><a href=\"https://junghyungil.tistory.com/96\">블로그 글</a></li>\n</ul>","excerpt":"학습 동기 알고리즘 문제를 풀면서 배열과 ArrayList 의 가장 큰 차이는 메모리가 고정되어 있는지, 동적으로 늘어나는지에 따라 상황에 맞게 사용했었습니다. 그런데 문득 ArrayList 도 내부는 배열로 되어 있는데 어떤 방식으로 사이즈가 동적으로 늘어날까 궁금해졌습니다. ArrayList 내부 구조 최초에는 빈 배열로 생성되었다가 add 가 한번이라도 생성 되는 시점에 빈 배열이라면 기본 값인 10으로 사이즈 설정을 해줍니다. 그리고 원소의 개수가 10을 넘었을 때, 해당 배열의 사이즈의 절반만큼 크기를 늘려주고 있습니다. 중간 삽입(add(index, data) 이나 삭제 할 때 (remove) 동작 원리 Index 없이 삽입할 때는 배열의 바로 뒤에 삽입하기 때문에 원소를 뒤로 밀 필요가 없는데, 만약에 삽입시 index 를 지정해서 삽입하는 경우나 첫번째부터 맨 뒤 바로 앞 원소를 삭제하는 경우는 배열을 밀거나 당겨줘야한다. 내부 구현체에서는   를 사용하여 해당 인덱…","frontmatter":{"date":"December 16, 2022","title":"ArrayList 가 동적으로 사이즈가 늘어나는 동작 원리!","categories":"cs","author":"수달","emoji":"🙂"},"fields":{"slug":"/java2/"}},"next":{"id":"e71a303f-3520-5029-a3fa-4840d569e124","html":"<blockquote>\n<p>해당 글은 Stream 에 대해 알고 있다는 가정하에 작성되었습니다.</p>\n</blockquote>\n<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>프로그래머스에서 <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42578\">위장</a> 이라는 문제를 풀다가 모든 경우의 수를 찾아보는데 조합으로 풀면 간단하겠다고 생각이 들었고, 조합을 풀면서 재귀나 반복으로 풀기보다 Java Stream 에서 제공하는 기능으로 문제를 풀어보면 좋겠다고 생각되었습니다. 해당 글은 Stream 에 대해 알고 있다는 가정하에 작성되었습니다.</p>\n<h2 id=\"reduce-란\" style=\"position:relative;\"><a href=\"#reduce-%EB%9E%80\" aria-label=\"reduce 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reduce() 란?</h2>\n<p>반복된 패턴을 추상화 할 수 있는 강력한 기능입니다. 스트림의 특성상  for 문처럼 원소들이 하나씩 아래로 들어오게 되는데요.  <code class=\"language-text\">reduce()</code>는 스트림의 원소들을 하나씩 소모해가며, 누적 계산을 수행하고 결과값을 리턴하는 메서드 입니다.</p>\n<p><code class=\"language-text\">reduce()</code>는 파라미터를 3개 받을 수 있어요.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">T identity</code>: 계산에 적용할 초깃값으로, 스트림이 비어 있더라도 초깃값을 반환</p>\n<p>만약에 값을 누적하면서 곱하고 싶다면 기본 값이 1이어야 하겠죠?</p>\n</li>\n<li>\n<p><code class=\"language-text\">BinaryOperator&lt;T> accumulator</code>: 적용할 계산 함수</p>\n<p>더하거나, 곱하거나, 빼거나 이런 연산을 수행해요.</p>\n</li>\n<li>\n<p><code class=\"language-text\">BinaryOperator&lt;U> combiner</code>: 병렬 스트림에서 각 쓰레드 계산 결과를 합치는 함수</p>\n<p><code class=\"language-text\">accumulator</code> 를 통해 나온 값을 누적해요.</p>\n</li>\n</ul>\n<h2 id=\"문제-상황\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%83%81%ED%99%A9\" aria-label=\"문제 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 상황</h2>\n<p>스파이가 위장을 하기 위해서 <code class=\"language-text\">모자</code>(비니, 나이키 엘로우 캡),  <code class=\"language-text\">아우터</code>(가죽자켓, 후드티), <code class=\"language-text\">양말</code>(빨간색, 파란색, 노란색) 이 있다고 할 때, 하루에 각 종류별로 1개 이상 착용해야하고, 동일한 종류의 의류를 착용할 수 없다는 제약 조건이 있었어요. 그래서 모든 경우의 수를 찾아야 했어요.</p>\n<ul>\n<li>\n<p>만약에 옷의 종류가 1개라고 해본다면  총 a가지의 경우가 있겠죠?</p>\n</li>\n<li>\n<p>종류가 2개가 되고 각각의 옷의 개수는 a, b개입니다</p>\n<p>그럼 경우의 수는 a, b, ab가 되므로 조합의 개수는 (a+b) + (ab)가지입니다.</p>\n</li>\n<li>\n<p>3개가 된다면? (a+b+c) + (ab+bc+ca) + (abc)가지입니다.</p>\n</li>\n</ul>\n<p>이런 문제 풀이는 다항식을 적용해볼 수 있어요.</p>\n<p>(x+a)(x+b)(x+c) = x3 + (a+b+c)x2 + (ab+bc+ca)x + (abc)라는 식을 도출할 수 있습니다.</p>\n<p>해당 식의 계수의 합을 구하려면 x=1을 대입해주면 됩니다. 그 후 맨 앞 x3 의 계수는 정답에 포함되지 않으므로 마지막에 1을 빼주면 됩니다. .x=1을 대입한 식은 <code class=\"language-text\">(1+a)(1+b)(1+c)</code>가 되고 그 값에 1을 빼면 모든 경우의 수가 나오게 됩니다!</p>\n<h3 id=\"사용한-reduce-2개-파라미터-메서드\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%9C-reduce-2%EA%B0%9C-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"사용한 reduce 2개 파라미터 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용한 reduce 2개 파라미터 메서드</h3>\n<h3 id=\"code-classlanguage-textt-reducet-identity-binaryoperatorltt-accumulatorcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textt-reducet-identity-binaryoperatorltt-accumulatorcode\" aria-label=\"code classlanguage textt reducet identity binaryoperatorltt accumulatorcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">T reduce(T identity, BinaryOperator&lt;T> accumulator)</code></h3>\n<p>결과의 초깃값을 <code class=\"language-text\">identity</code>로 설정한 후, 스트림의 모든 <code class=\"language-text\">element</code>를 차례로 돌면서 <code class=\"language-text\">accumulator</code>를 적용하며 <code class=\"language-text\">result</code>를 갱신합니다. .스트림이 비어 있어도 초깃값인 <code class=\"language-text\">identity</code>를 반환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">T</span> result <span class=\"token operator\">=</span> identity<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> element <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span> stream<span class=\"token punctuation\">)</span>\n    result <span class=\"token operator\">=</span> accumulator<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></code></pre></div>\n<p>사용 예시는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">IntStream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> a<span class=\"token operator\">*</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 결과값은 60 이다. </span></code></pre></div>\n<h2 id=\"hashmap-과-조합을-사용할-때는\" style=\"position:relative;\"><a href=\"#hashmap-%EA%B3%BC-%EC%A1%B0%ED%95%A9%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EB%8A%94\" aria-label=\"hashmap 과 조합을 사용할 때는 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HashMap 과 조합을 사용할 때는?</h2>\n<p>주어진 데이터가 String, 문자열 배열 이더라도,  key 값에는 고유 값을 두고,  value 에  배열의 개수를 두면 조합을 통해서 값을 계산하기 한결 수월해집니다!</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> clothes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 문자열 배열로 주어진 데이터</span>\n\t\t<span class=\"token punctuation\">.</span>\n\t\t<span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> total <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> clothes<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\ttotal<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>clothes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> total<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>clothes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token keyword\">final</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> values <span class=\"token operator\">=</span> total<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">int</span> answer <span class=\"token operator\">=</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> a<span class=\"token operator\">*</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"date":"December 14, 2022","title":"Stream의 reduce() 로 조합 계산하기","categories":"java","author":"수달","emoji":"🙂"},"fields":{"slug":"/java7/"}},"prev":{"id":"ef2f5533-0bce-52dd-86ee-87a658d3517f","html":"<h2 id=\"학습-동기\" style=\"position:relative;\"><a href=\"#%ED%95%99%EC%8A%B5-%EB%8F%99%EA%B8%B0\" aria-label=\"학습 동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>학습 동기</h2>\n<p>평소에 목록을 저장하기 위해서 배열이나 List 자료 형을 썼었는데, 배열과 ArrayList 는 메모리 크기가 고정되어 있는지, 동적으로 커지는지에 차이가 있다고 생각되어 구분하여 잘 사용 했었습니다. 그런데 알고리즘을 풀면서 LinkedList 와는 잘 비교해서 사용하지 않았던 것 같아서 정리해보고자 합니다.</p>\n<h2 id=\"배열arrays\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4arrays\" aria-label=\"배열arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열(Arrays)</h2>\n<ul>\n<li>배열은 입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 자료구조에요</li>\n<li>Index 를 통해서 접근이 가능하고 0 번부터 시작합니다.</li>\n<li>최초 크기가 고정되면 바꿀 수 없어요.</li>\n</ul>\n<h3 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<ul>\n<li>조회는 접근하고자 하는 인덱스만 안다면 O(1) 시간이 걸려요.\n<ul>\n<li>순차 탐색시는 최대 O(n) 이 소모됩니다.</li>\n</ul>\n</li>\n<li>삽입 및 삭제\n<ul>\n<li>\n<p>배열의 <code class=\"language-text\">처음 또는 중간</code> 삽입, 삭제 O(n)</p>\n<p>삭제된 원소 뒤에 있는 원소들을 한칸씩 옮겨야 해서 O(n) 이 소모됩니다.</p>\n</li>\n<li>\n<p>배열의 <code class=\"language-text\">끝</code>에 삽입 및 삽입, 삭제  O(1)</p>\n<p>가장 뒤에는 옮길 원소가 없기 때문에 O(1) 이 소모됩니다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"사용하면-좋은-상황\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%83%81%ED%99%A9\" aria-label=\"사용하면 좋은 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용하면 좋은 상황</h3>\n<p>ArraysList 같은 경우는 메모리가 초과됐을 경우 특정 크기를 1.5배씩 증가 시키기 때문에 메모리 낭비가 있을 수 있어서 전체 원소의 메모리 사이즈를 알고 있다면 배열을 사용하는게 좋을 것 같아요.</p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>연결 리스트는 여러개의 노드가 순차적으로 연결된 형태를 가지는 자료구조이며, 첫번째 노드를 HEAD , 마지막 노드를 TAIL 이라고 합니다.</p>\n<h3 id=\"원형-linkedlist-node-구조\" style=\"position:relative;\"><a href=\"#%EC%9B%90%ED%98%95-linkedlist-node-%EA%B5%AC%EC%A1%B0\" aria-label=\"원형 linkedlist node 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원형 LinkedList Node 구조</h3>\n<ul>\n<li>data  와 Next node 주소값을 가져요.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Object</span> data<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"특징\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95\" aria-label=\"특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>배열과 다르게 메모리를 연속적으로 사용하지 않아요!</li>\n<li>index 로 접근할 수 없기 때문에 순차 접근에는 분리할 수 있으나 노드가 연결된 구조이기 때문에 중간 삽입, 삭제시, 앞 뒤 노드만 연결해주면 되기 때문에 훨씬 효율적이에요!</li>\n</ul>\n<h3 id=\"시간-복잡도-1\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-1\" aria-label=\"시간 복잡도 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<ul>\n<li>조회에는 O(n) 시간이 소모됩니다.</li>\n<li>맨 앞 삽입,삭제 자체는 O(1) 이지만 중간 삽입,삭제는 탐색 시간이 소요되어 O(n) 이 걸려요.\n<ul>\n<li>연결리스트 맨 끝에 삽입할 때 만약 마지막 노드의 위치를 알고 있다면 O(1) 시간만으로도 해결할 수 있어요.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"삽입-flow\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85-flow\" aria-label=\"삽입 flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입 flow</h3>\n<ul>\n<li>노드를 생성하고, 삽입하려는 위치를 찾아요</li>\n<li>위치를 찾았으면, <code class=\"language-text\">삽입하려는 노드</code>가 그 위치에 <code class=\"language-text\">다음 노드를 가리키게</code> 합니다.</li>\n<li>삽입하려는 위치에 <code class=\"language-text\">이전 노드</code>는 <code class=\"language-text\">삽입 노드를 가리키게</code> 합니다.</li>\n</ul>\n<h3 id=\"삭제-flow\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C-flow\" aria-label=\"삭제 flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제 flow</h3>\n<ul>\n<li><code class=\"language-text\">탐색을 통해서 삭제하려는 노드</code>를 찾습니다.</li>\n<li>삭제하려는 노드의 왼쪽 노드를 삭제하려는 노드의 오른쪽을 가리키게 합니다.</li>\n<li>삭제하려는 노드의 <code class=\"language-text\">nextNode 를 null로</code> 만들어줍니다.</li>\n</ul>\n<h3 id=\"사용하면-좋을-상황\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84-%EC%83%81%ED%99%A9\" aria-label=\"사용하면 좋을 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용하면 좋을 상황</h3>\n<p>삽입과 삭제에서 배열보다 유리하기 때문에 삽입 삭제가 빈번히 발생하고 검색이 적을 때 사용하면 좋을 것 같습니다. 그 중에서도 삽입 삭제가 맨 앞에서 일어나는 상황이라면 더 LinkedList의 장점을 극대화해서 사용할 수 있겠습니다 ㅎㅎ</p>\n<h3 id=\"이중-linkedlist--node-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A4%91-linkedlist--node-%EA%B5%AC%EC%A1%B0\" aria-label=\"이중 linkedlist  node 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이중 LinkedList  Node 구조</h3>\n<ul>\n<li>prev Node  주소값과 data,  Next node 주소값을 가져요.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">E</span> item<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"특징-1\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-1\" aria-label=\"특징 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>위에서 언급한 단순 연결리스트와는 다르게 전, 후로 탐색이 가능한 구조입니다. 이전 노드주소와 이후 노드 주소를 한 노드에서 모두 알고 있습니다!</li>\n<li>가장 마지막 노드를 기억하고 있는 tail ! 만약 탐색하고 싶은 노드가 가장 뒤에서 부터라면 뒤에서 앞으로 탐색할 수 있어서 탐색 시간을 줄일 수 있어요.</li>\n</ul>\n<h2 id=\"느낀점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\"느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀점</h2>\n<p>자료구조 내부에 동작원리를 알게 되므로 코드를 작성할 때 타입 선택을 할때 메모리가 고정되어 있다면 배열을 사용하고, 동적이라면 ArrayList, 검색은 별로 안하지만 삽입 삭제가 많으면 LinkedList 를 사용해야겠다는 것을 알게 되었어요. 자료형을 선택할 때는 항상 이유있는 선택을 해야겠어요.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Arrays.html\">Arrays javadoc</a></li>\n<li><a href=\"https://hongcoding.tistory.com/74\">블로그 글</a></li>\n</ul>","frontmatter":{"date":"December 16, 2022","title":"Arrays vs LinkedList","categories":"java CS","author":"수달","emoji":"🙂"},"fields":{"slug":"/java3/"}},"site":{"siteMetadata":{"siteUrl":"https://her0807.com","comments":{"utterances":{"repo":"https://github.com/her0807/her0807.github.io"}}}}},"pageContext":{"slug":"/java2/","nextSlug":"/java7/","prevSlug":"/java3/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}